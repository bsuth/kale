local lfs = require('lfs')
local compile = require('erde.compile')
local config = require('erde.config')
local { COMPILED_FOOTER_COMMENT, VALID_LUA_TARGETS, VERSION } = require('erde.constants')
local lib = require('erde.lib')
local { io, string } = require('erde.stdlib')
local { ensure_path_parents, join_paths } = require('erde.utils')

local unpack = table.unpack || unpack
local pack = table.pack || (...) -> ({ n =  select("#", ...), ... })

local REPL_PROMPT = '> '
local REPL_SUB_PROMPT = '>> '
local HAS_READLINE, RL = pcall(() -> require('readline'))

local SUBCOMMANDS = {
  compile = true,
  clean = true,
  sourcemap = true,
}

-- -----------------------------------------------------------------------------
-- State
-- -----------------------------------------------------------------------------

-- The index of the current arg we are processing
local current_arg_index = 1

-- The total number of arguments passed to this script. Stored solely as an
-- optimization.
local num_args = #arg

-- A table of processed flags / args.
local cli = {}

-- A modified version of Lua's native `arg` to mimic the arg positions when
-- running the `erde` executable. This overrides `arg` when we are running an
-- `.erde` script in case the script tries to access `arg` itself.
local script_args = {}

-- -----------------------------------------------------------------------------
-- Helpers
-- -----------------------------------------------------------------------------

local function terminate(message, status = 1) {
  print(message)
  os.exit(status)
}

local function parse_option(label) {
  current_arg_index = current_arg_index + 1
  local arg_value = arg[current_arg_index]

  if !arg_value {
    terminate("Missing argument for { label }")
  }

  return arg_value
}

local function traverse(paths, pattern, callback) {
  for _, path in ipairs(paths) {
    local attributes = lfs.attributes(path)

    if attributes == nil {
      continue
    }

    if attributes.mode == 'file' {
      if path:match(pattern) {
        callback(path, attributes)
      }
    } elseif attributes.mode == 'directory' {
      local subpaths = {}

      for filename in lfs.dir(path) {
        if filename  != '.' && filename != '..' {
          table.insert(subpaths, join_paths(path, filename))
        }
      }

      traverse(subpaths, pattern, callback)
    }
  }
}

-- Check whether a file has been generated from `erde` by checking if the file
-- ends with `COMPILED_FOOTER_COMMENT`.
local function is_compiled_file(path) {
  local file = io.open(path, 'r')

  if file == nil {
    return false
  }

  -- Some editors save an invisible trailing newline, so read an extra char just
  -- in case.
  local read_len = #COMPILED_FOOTER_COMMENT + 1

  file:seek('end', -read_len)
  local footer = file:read(read_len)
  file:close()

  return !!(footer && footer:find(COMPILED_FOOTER_COMMENT))
}

-- -----------------------------------------------------------------------------
-- Help
-- -----------------------------------------------------------------------------

local HELP = [[
Usage: erde [command] [args]

Commands:
   compile                Compile Erde files into Lua.
   clean                  Remove generated Lua files.
   sourcemap              Map a compiled (Lua) line to a source (Erde) line.

Options:
   -h, --help             Show this help message and exit.
   -v, --version          Show version and exit.
   -b, --bitlib <LIB>     Library to use for bit operations.
   -t, --target <TARGET>  Lua target for version compatability.
                          Must be one of: { table.concat(VALID_LUA_TARGETS, ', ') }

Compile Options:
   -o, --outdir <DIR>     Output directory for compiled files.
   -w, --watch            Watch files and recompile on change.
   -f, --force            Force rewrite existing Lua files with compiled files.
   -p, --print            Print compiled code instead of writing to files.

Examples:
   erde
      Launch the REPL.

   erde my_script.erde
      Run my_script.erde.

   erde compile my_script.erde
      Compile my_script.erde (into my_script.lua).

   erde compile .
      Compile all *.erde files under the current directory.

   erde compile src -o dest
      Compile all *.erde files in src and place the *.lua files under dest.

   erde clean my_script.lua
      Remove my_script.lua if and only if it has been generated by `erde compile`.

   erde clean .
      Remove all generated *.lua files under the current directory.

   erde sourcemap my_script.erde 114
      Lookup which line in my_script.erde generated line 114 in my_script.lua.
]]

-- -----------------------------------------------------------------------------
-- Run Command
-- -----------------------------------------------------------------------------

-- IMPORTANT: THIS IS AN ERDE SOURCE LOADER AND MUST ADHERE TO THE USAGE SPEC OF
-- `__erde_internal_load_source__`!
local function run_command() {
  lib.load(cli.target)

  -- Replace Lua's global args with what the script expects as if it were run
  -- from the Lua VM directly.
  arg = script_args

  local ok, result = xpcall(() -> {
    local source = io.readfile(cli.script)
    local result = lib.__erde_internal_load_source__(source, { alias = cli.script })
    return result
  }, lib.traceback)

  if !ok {
    terminate('erde: ' .. result)
  }
}

-- -----------------------------------------------------------------------------
-- Compile Command
-- -----------------------------------------------------------------------------

local function compile_file(path) {
  local compile_path = path:gsub('%.erde$', '.lua')

  if cli.outdir {
    compile_path = cli.outdir .. '/' .. compile_path
  }

  if !cli.print_compiled && !cli.force {
    if io.exists(compile_path) && !is_compiled_file(compile_path) {
      print("{ path } => ERROR")
      print("Cannot write to { compile_path }: file already exists")
      return false
    }
  }

  local ok, result = pcall(() -> compile(io.readfile(path), { alias = path }))

  if !ok {
    print("{ path } => ERROR")

    if type(result == 'table') && result.line {
      print("erde:{ result.line }: { result.message }")
    } else {
      print("erde: { result }")
    }

    return false
  }

  if cli.print_compiled {
    print(path)
    print(('-'):rep(#path))
    print(result)
  } else {
    ensure_path_parents(compile_path)
    io.writefile(compile_path, result)

    if cli.watch {
      print("[{ os.date('%X') }] { path } => { compile_path }")
    } else {
      print("{ path } => { compile_path }")
    }
  }

  return true
}

local function watch_files(cli) {
  local modifications = {}
  local poll_interval = 1 -- seconds

  local has_socket, socket = pcall(() -> require('socket'))
  local has_posix, posix = pcall(() -> require('posix.unistd'))

  if !has_socket && !has_posix {
    print(table.concat({
      'WARNING: No libraries with sleep functionality found. This may ',
      'cause high CPU usage while watching. To fix this, you can install ',
      'either LuaSocket (https://luarocks.org/modules/luasocket/luasocket) ',
      'or luaposix (https://luarocks.org/modules/gvvaughan/luaposix)\n',
    }))
  }

  while true {
    traverse(cli, '%.erde$', (path, attributes) -> {
      if !modifications[path] || modifications[path] != attributes.modification {
        modifications[path] = attributes.modification
        compile_file(path, cli)
      }
    })

    if has_socket {
      socket.sleep(poll_interval)
    } elseif has_posix {
      posix.sleep(poll_interval)
    } else {
      local last_timeout = os.time()
      repeat {} until os.time() - last_timeout > poll_interval
    }
  }
}

local function compile_command() {
  if #cli == 0 {
    table.insert(cli, '.')
  }

  if cli.watch {
    -- Use pcall to catch SIGINT
    pcall(() -> watch_files(cli))
  } else {
    traverse(cli, '%.erde$', path -> {
      if !compile_file(path, cli) {
        os.exit(1)
      }
    })
  }
}

-- -----------------------------------------------------------------------------
-- Clean Command
-- -----------------------------------------------------------------------------

local function clean_command() {
  if #cli == 0 {
    table.insert(cli, '.')
  }

  traverse(cli, '%.lua$', path -> {
    if is_compiled_file(path) {
      os.remove(path)
      print("{ path } => DELETED")
    }
  })
}

-- -----------------------------------------------------------------------------
-- Sourcemap Command
-- -----------------------------------------------------------------------------

local function sourcemap_command() {
  local path, line = cli[1], cli[2]

  if path == nil {
    terminate('Missing erde file to map')
  } elseif line == nil {
    terminate('Missing line number to map')
  }

  local ok, result, source_map = pcall(() -> compile(io.readfile(path), { alias = path }))

  if ok {
    print("{ line } => { source_map[tonumber(line)] }")
  } else {
    print("Failed to compile { path }")

    if type(result == 'table') && result.line {
      print("erde:{ result.line }: { result.message}")
    } else {
      print("erde: { result }")
    }
  }
}

-- -----------------------------------------------------------------------------
-- REPL Command
-- -----------------------------------------------------------------------------

local function readline(prompt) {
  if HAS_READLINE {
    return RL.readline(prompt)
  } else {
    io.write(prompt)
    return io.read()
  }
}

local function repl() {
  print("Erde { VERSION } on { _VERSION } -- Copyright (C) 2021-2023 bsuth")

  if !HAS_READLINE {
    print('Install the `readline` Lua library to get support for arrow keys, keyboard shortcuts, history, etc.')
  }

  while true {
    local ok, result
    local source = readline(REPL_PROMPT)

    -- Readline returns the string '(null)' on <C-d> for some reason.
    if !source || (HAS_READLINE && source == '(null)') {
      break
    }

    repeat {
      -- Try input as an expression first! This way we can still print the value
      -- in the case that the expression is also a valid block (i.e. function calls).
      --
      -- Pack results so we know how many were actually returned, even if there
      -- are nils among them.
      ok, result = pcall(() -> pack(lib.run("return { source }", { alias = 'stdin' })))

      if !ok && type(result) == 'string' && !result:find('unexpected eof') {
        -- Try input as a block
        ok, result = pcall(() -> pack(lib.run(source, { alias = 'stdin' })))
      }

      if !ok && type(result) == 'string' && result:find('unexpected eof') {
        repeat {
          local subsource = readline(REPL_SUB_PROMPT)
          source ..= subsource || ''
        } until subsource
      }
    } until ok || type(result) != 'string' || !result:find('unexpected eof')

    if !ok {
      print(lib.rewrite(result))
    } elseif result.n > 0 {
      for i = 1, result.n {
        -- explicitly call `tostring()` so nils are also stringified
        result[i] = tostring(result[i])
      }
      print(unpack(result))
    }

    if HAS_READLINE && string.trim(source) != '' {
      RL.add_history(source)
    }
  }
}

local function repl_command() {
  lib.load(cli.target)

  if HAS_READLINE {
    RL.set_readline_name('erde')
    RL.set_options({
      keeplines = 1000,
      histfile = '~/.erde_history',
      completion = false,
      auto_add = false,
    })
  }

  -- Protect repl so we don't show stacktraces when the user uses Control+c
  -- without readline.
  pcall(repl)

  if HAS_READLINE {
    RL.save_history()
  }
}

-- -----------------------------------------------------------------------------
-- Main
-- -----------------------------------------------------------------------------

config.is_cli_runtime = true

while current_arg_index <= num_args {
  local arg_value = arg[current_arg_index]

  if cli.script {
    -- Proxy all arguments after the script to the script itself
    -- (same as Lua interpreter behavior)
    table.insert(script_args, arg_value)
  } elseif !cli.subcommand && SUBCOMMANDS[arg_value] {
    cli.subcommand = arg_value
  } elseif arg_value == '-h' || arg_value == '--help' {
    terminate(HELP, 0)
  } elseif arg_value == '-v' || arg_value == '--version' {
    terminate(VERSION, 0)
  } elseif arg_value == '-w' || arg_value == '--watch' {
    cli.watch = true
  } elseif arg_value == '-f' || arg_value == '--force' {
    cli.force = true
  } elseif arg_value == '-p' || arg_value == '--print' {
    cli.print_compiled = true
  } elseif arg_value == '-t' || arg_value == '--target' {
    cli.target = parse_option(arg_value)
    config.lua_target = cli.target
    if !VALID_LUA_TARGETS[config.lua_target] {
      terminate(table.concat({
        "Invalid Lua target: { config.lua_target }",
        "Must be one of: { table.concat(VALID_LUA_TARGETS, ', ') }",
      }, '\n'))
    }
  } elseif arg_value == '-o' || arg_value == '--outdir' {
    cli.outdir = parse_option(arg_value)
  } elseif arg_value == '-b' || arg_value == '--bitlib' {
    config.bitlib = parse_option(arg_value)
  } elseif arg_value:sub(1, 1) == '-' {
    terminate("Unrecognized option: { arg_value }")
  } elseif !cli.subcommand && arg_value:match('%.erde$') {
    cli.script = arg_value
    script_args[-current_arg_index] = 'erde'
    for i = 1, current_arg_index {
      script_args[-current_arg_index + i] = arg[i]
    }
  } else {
    table.insert(cli, arg_value)
  }

  current_arg_index = current_arg_index + 1
}

if cli.subcommand == 'compile' {
  compile_command()
} elseif cli.subcommand == 'clean' {
  clean_command()
} elseif cli.subcommand == 'sourcemap' {
  sourcemap_command()
} elseif !cli.script {
  repl_command()
} elseif !io.exists(cli.script) {
  terminate("File does not exist: { cli.script }")
} else {
  run_command()
}
