local lfs = require('lfs')
local C = require('erde.constants')
local compile = require('erde.compile')
local lib = require('erde.lib')
local repl = require('erde.repl')
local utils = require('erde.utils')

local HELP = ([[
Usage: erde [command] [args]

Commands:
   compile                Compile Erde files into Lua.
   clean                  Remove generated Lua files.

Options:
   -h, --help             Show this help message and exit.
   -v, --version          Show version and exit.
   -d, --debug            Expose internal stack calls in tracebacks.
   -t, --target <TARGET>  Lua target for version compatability.
                          Must be one of: %s

Compile Options:
   -o, --outdir <DIR>     Output directory for compiled files.
   -b, --bitlib <LIB>     Library to use for compiled bit operations.
   -w, --watch            Watch files and recompile on change.
   -f, --force            Force rewrite existing Lua files with compiled files.
   -p, --print            Print compiled code instead of writing to files.

Examples:
   erde
      Launch the REPL.

   erde my_script.erde
      Run my_script.erde.

   erde compile my_script.erde
      Compile my_script.erde (into my_script.lua).

   erde compile .
      Compile all *.erde files under the current directory.

   erde compile src -o dest
      Compile all *.erde files in src and place the *.lua files under dest.

   erde clean my_script.lua
      Remove my_script.lua if and only if it has been generated by `erde compile`.

   erde clean .
      Remove all generated *.lua files under the current directory.
]]):format(table.concat(C.VALID_LUA_TARGETS, ', '))

local subcommand = nil
local outdir = nil
local watch = false
local force = false
local print_compiled = false
local args = {}
local script = nil
local script_index = nil

-- -----------------------------------------------------------------------------
-- Helpers
-- -----------------------------------------------------------------------------

local function terminate(message, status)
  print(message)
  os.exit(status or 1)
end

-- Check whether a file has been generated from `erde` by checking if the file
-- ends with `C.COMPILED_FOOTER_COMMENT`.
local function is_compiled_file(path)
  local file = io.open(path, 'r')

  if file == nil then
    return false
  end

  -- Some editors save an invisible trailing newline, so read an extra char just
  -- in case.
  local read_len = #C.COMPILED_FOOTER_COMMENT + 1

  file:seek('end', -read_len)
  local footer = file:read(read_len)
  file:close()

  return footer:find(C.COMPILED_FOOTER_COMMENT)
end

local function traverse(paths, pattern, callback)
  for i, path in ipairs(paths) do
    local attributes = lfs.attributes(path)

    if attributes ~= nil then
      if attributes.mode == 'file' then
        if pattern == nil or path:match(pattern) then
          callback(path, attributes)
        end
      elseif attributes.mode == 'directory' then
        local subpaths = {}

        for filename in lfs.dir(path) do
          if filename ~= '.' and filename ~= '..' then
            table.insert(subpaths, utils.join_paths(path, filename))
          end
        end

        traverse(subpaths, pattern, callback)
      end
    end
  end
end

-- -----------------------------------------------------------------------------
-- Actions
-- -----------------------------------------------------------------------------

local function compile_file(src_path, show_timestamp)
  local dest_path = src_path:gsub('%.erde$', '.lua')
  if outdir then dest_path = outdir .. '/' .. dest_path end

  if not print_compiled and not force then
    if utils.file_exists(dest_path) and not is_compiled_file(dest_path) then
      print(src_path .. ' => ERROR')
      print('Cannot write to ' .. dest_path .. ': _file already exists')
      return false
    end
  end

  local src_file = io.open(src_path, 'r')
  local src = src_file:read('*a')
  src_file:close()

  local ok, result = pcall(function()
    return compile(src)
  end)

  if not ok then
    print(src_path .. ' => ERROR')

    if type(result == 'table') and result.line then
      print(('erde:%d: %s'):format(result.line, result.message))
    else
      print('erde: ' .. tostring(result))
    end

    return false
  end

  if print_compiled then
    print(src_path)
    print(('-'):rep(#src_path))
    print(result)
  else
    local dest_file = io.open(dest_path, 'w')
    dest_file:write(result)
    dest_file:close()

    if show_timestamp then
      print(('[%s] %s => %s'):format(os.date('%X'), src_path, dest_path))
    else
      print(('%s => %s'):format(src_path, dest_path))
    end
  end

  return true
end

local function watch_files(paths)
  local modifications = {}
  local poll_interval = 1 -- seconds

  local has_socket, socket = pcall(function() return require('socket') end)
  local has_posix, posix = pcall(function() return require('posix.unistd') end)
  if not has_socket and not has_posix then
    print(table.concat({
      'WARNING: No libraries with sleep functionality found. This will ',
      'cause high CPU usage while watching. To fix this, you can install ',
      'either LuaSocket (https://luarocks.org/modules/luasocket/luasocket) ',
      'or luaposix (https://luarocks.org/modules/gvvaughan/luaposix)\n',
    }))
  end

  while true do
    traverse(paths, '%.erde$', function(path, attributes)
      if not modifications[path] or modifications[path] ~= attributes.modification then
        modifications[path] = attributes.modification
        compile_file(path, true)
      end
    end)

    if has_socket then
      socket.sleep(poll_interval)
    elseif has_posix then
      posix.sleep(poll_interval)
    else
      local last_timeout = os.time()
      repeat until os.time() - last_timeout > poll_interval
    end
  end
end

-- IMPORTANT: THIS IS AN ERDE SOURCE LOADER AND MUST ADHERE TO THE USAGE SPEC OF
-- `__erde_internal_load_source__`!
local function run_file(path)
  local ok, result = pcall(function()
    local source = utils.read_file(path)
    local result = lib.__erde_internal_load_source__(source, path)
    return result
  end)

  if not ok then
    if type(result) == 'table' and result.__is_erde_error__ then
      terminate('erde: ' .. (result.stacktrace or result.message))
    else
      terminate(table.concat({
        'Internal error: ' .. tostring(result),
        'Please report this at: https://github.com/erde-lang/erde/issues',
      }, '\n'))
    end
  end
end

-- -----------------------------------------------------------------------------
-- CLI Parsing
-- -----------------------------------------------------------------------------

local cli_inputs = arg
local cli_inputs_index = 1

local function cli_option(label)
  cli_inputs_index = cli_inputs_index + 1
  local option_value = cli_inputs[cli_inputs_index]

  if not option_value then
    terminate('Missing argument for ' .. label)
  end

  return option_value
end

if cli_inputs[1] == 'compile' or cli_inputs[1] == 'clean' then
  subcommand = cli_inputs[1]
  cli_inputs_index = cli_inputs_index + 1
end

while cli_inputs_index <= #cli_inputs do
  local cli_input = cli_inputs[cli_inputs_index]

  if script then
    -- Proxy all arguments after the script to the script itself
    -- (same as Lua interpreter behavior)
    table.insert(args, cli_input)
  elseif cli_input == '-h' or cli_input == '--help' then
    terminate(HELP, 0)
  elseif cli_input == '-v' or cli_input == '--version' then
    terminate(C.VERSION, 0)
  elseif cli_input == '-d' or cli_input == '--debug' then
    C.DEBUG = true
  elseif cli_input == '-w' or cli_input == '--watch' then
    watch = true
  elseif cli_input == '-f' or cli_input == '--force' then
    force = true
  elseif cli_input == '-p' or cli_input == '--print' then
    print_compiled = true
  elseif cli_input == '-t' or cli_input == '--target' then
    C.LUA_TARGET = cli_option(cli_input)
    if not C.VALID_LUA_TARGETS[C.LUA_TARGET] then
      terminate(table.concat({
        'Invalid Lua target: ' .. C.LUA_TARGET,
        'Must be one of: ' .. table.concat(C.VALID_LUA_TARGETS, ', '),
      }, '\n'))
    end
  elseif cli_input == '-o' or cli_input == '--outdir' then
    outdir = cli_option(cli_input)
  elseif cli_input == '-b' or cli_input == '--bitlib' then
    C.BITLIB = cli_option(cli_input)
  elseif cli_input:sub(1, 1) == '-' then
    terminate('Unrecognized option: ' .. cli_input)
  elseif not subcommand and cli_input:match('%.erde$') then
    script = cli_input
    script_index = cli_inputs_index
  else
    table.insert(args, cli_input)
  end

  cli_inputs_index = cli_inputs_index + 1
end

-- -----------------------------------------------------------------------------
-- Main
-- -----------------------------------------------------------------------------

C.IS_CLI_RUNTIME = true

if subcommand == 'compile' then
  if #args == 0 then
    terminate('Missing arg')
  elseif watch then
    -- Use pcall to catch SIGINT
    pcall(function() watch_files(args) end)
  else
    traverse(args, '%.erde$', function(path)
      if not compile_file(path) then
        os.exit(1)
      end
    end)
  end
elseif subcommand == 'clean' then
  if #args == 0 then
    terminate('Missing arg')
  end
  traverse(args, '%.lua$', function(path)
    if is_compiled_file(path) then
      os.remove(path)
      print(path .. ' => DELETED')
    end
  end)
elseif not script then
  repl()
elseif not utils.file_exists(script) then
  terminate('File does not exist: ' .. script)
else
  arg = args
  arg[-script_index] = 'erde'

  for i = script_index, 1, -1 do
    arg[i - script_index] = cli_inputs[i]
  end

  lib.load()
  run_file(script)
end
