local config = require('erde.config')
local {
  BINOP_ASSIGNMENT_TOKENS,
  BINOPS,
  BITOPS,
  BITLIB_METHODS,
  COMPILED_FOOTER_COMMENT,
  DIGIT,
  KEYWORDS,
  LEFT_ASSOCIATIVE,
  LUA_KEYWORDS,
  SURROUND_ENDS,
  TERMINALS,
  TOKEN_TYPES,
  UNOPS,
  VERSION,
} = require('erde.constants')
local { table } = require('erde.stdlib')
local tokenize = require('erde.tokenize')
local { get_source_alias } = require('erde.utils')

local unpack = table.unpack || unpack

-- Foward declare
local arrow_function, block, expression, statement

-- -----------------------------------------------------------------------------
-- State
-- -----------------------------------------------------------------------------

-- Tokenization results.
local tokens

-- The index in `tokens` of the current token we are processing.
local current_token_index

-- The current token we are processing. Always equivalent to
-- `tokens[current_token_index]`.
local current_token

-- Current block depth during parsing
local block_depth

-- Counter for generating unique names in compiled code.
local tmp_name_counter

-- Break name to use for `continue` statements. This is also used to validate
-- the context of `break` and `continue`.
local break_name

-- Flag to keep track of whether the current block has any `continue` statements.
local has_continue

-- Keeps track of whether the module has any `module` declarations.
local has_module_declarations

-- Keeps track of whether the module has a `return` statement. Used to warn the
-- developer if they try to combine `return` with `module` scopes.
local is_module_return_block, module_return_line

-- Keeps track of whether the current block can use varargs as an expression.
-- Required since the Lua _parser_ will throw an error if varargs are used
-- outside a vararg function.
local is_varargs_block

-- Keeps track of the declared names in each block, along with their
-- declaration type.
local block_declarations, block_declaration_stack

-- Keeps track of the declared `goto` jump and label names. Required since Lua
-- throws errors at PARSE time if `goto` is used with an unfindable label.
local goto_jumps, goto_labels

-- Name for the current source being compiled (used in error messages)
local alias

-- Lua targets to support when generating compiled code.
local lua_target

-- Resolved bit library to use for compiling bit operations.
local bitlib

-- -----------------------------------------------------------------------------
-- General Helpers
-- -----------------------------------------------------------------------------

local function throw(message, line = current_token.line) {
  -- Use error level 0 since we already include alias
  error("{ alias }:{ line }: { message }", 0)
}

local function add_block_declaration(var, scope, stack_depth = block_depth) {
  if block_declaration_stack[stack_depth] == nil {
    for i = stack_depth - 1, 1, -1 {
      local parent_block_declarations = block_declaration_stack[i]

      if parent_block_declarations != nil {
        block_declaration_stack[stack_depth] = table.shallowcopy(parent_block_declarations)
        break
      }
    }
  }

  local target_block_declarations = block_declaration_stack[stack_depth]

  if type(var) == 'string' {
    target_block_declarations[var] = scope
  } else {
    for _, declaration_name in ipairs(var.declaration_names) {
      target_block_declarations[declaration_name] = scope
    }
  }
}

-- -----------------------------------------------------------------------------
-- Parse Helpers
-- -----------------------------------------------------------------------------

local function consume() {
  local consumed_token_value = current_token.value
  current_token_index += 1
  current_token = tokens[current_token_index]
  return consumed_token_value
}

local function branch(token) {
  if token == current_token.value {
    consume()
    return true
  }
}

local function expect(token, should_consume) {
  if current_token.type == TOKEN_TYPES.EOF {
    throw("unexpected eof (expected { token })")
  }

  if token != current_token.value {
    throw("expected '{ token }' got '{ current_token.value }'")
  }

  if should_consume {
    return consume()
  }
}

local function look_past_surround(token_start_index = current_token_index) {
  local surround_start_token = tokens[token_start_index]
  local surround_end = SURROUND_ENDS[surround_start_token.value]
  local surround_depth = 1

  local look_ahead_token_index = token_start_index + 1
  local look_ahead_token = tokens[look_ahead_token_index]

  repeat {
    if look_ahead_token.type == TOKEN_TYPES.EOF {
      throw("unexpected eof, missing '{ surround_end }'", surround_start_token.line)
    }

    if look_ahead_token.value == surround_start_token.value {
      surround_depth += 1
    } elseif look_ahead_token.value == surround_end {
      surround_depth -= 1
    }

    look_ahead_token_index += 1
    look_ahead_token = tokens[look_ahead_token_index]
  } until surround_depth == 0

  return look_ahead_token, look_ahead_token_index
}

-- -----------------------------------------------------------------------------
-- Compile Helpers
-- -----------------------------------------------------------------------------

local function new_tmp_name() {
  tmp_name_counter += 1
  return "__ERDE_TMP_{ tmp_name_counter }__"
}

local function get_compile_name(name, scope) {
  if scope == 'module' {
    if LUA_KEYWORDS[name] {
      return "_MODULE['{ name }']"
    } else {
      return '_MODULE.' .. name
    }
  } elseif scope == 'global' {
    if LUA_KEYWORDS[name] {
      return "_G['{ name }']"
    } else {
      return '_G.' .. name
    }
  }

  if LUA_KEYWORDS[name] {
    return "{ name }_" -- transform Lua keywords
  } else {
    return name
  }
}

local function weave(t, separator = ',') {
  local woven = {}
  local len = #t

  for i = 1, len - 1 {
    table.insert(woven, t[i])

    if type(t[i]) != 'number' {
      table.insert(woven, separator)
    }
  }

  table.insert(woven, t[len])

  return woven
}

local function compile_binop(op_token, op_line, lhs, rhs) {
  local needs_floor_division_polyfill = (
    op_token == '//' &&
    lua_target != '5.3' &&
    lua_target != '5.4' &&
    lua_target != '5.3+' &&
    lua_target != '5.4+'
  )

  if needs_floor_division_polyfill {
    -- SOURCEMAP: Handle incompatible argument types (`math.floor`)
    -- SOURCEMAP: Handle incompatible operand types (`/`)
    return { op_line, 'math.floor(', lhs, op_line, '/', rhs, ')' }
  } elseif bitlib && BITOPS[op_token] {
    -- NOTE: We wrap the bitlib call in parentheses to prevent tail calls in
    -- LuaJIT, since any errors will have a misleading stacktrace.
    -- see: https://www.freelists.org/post/luajit/Bad-stack-trace-from-lua-getstack-and-lua-getinfo,1
    --
    -- SOURCEMAP: Handle incompatible argument types
    return { op_line, "(require('{ bitlib }').{ BITLIB_METHODS[op_token] }(", lhs, ',', rhs, '))' }
  } elseif op_token == '!=' {
    return { lhs, '~=', rhs }
  } elseif op_token == '==' {
    return { lhs, op_token, rhs }
  } elseif op_token == '||' {
    return { lhs, 'or', rhs }
  } elseif op_token == '&&' {
    return { lhs, 'and', rhs }
  } else {
    -- SOURCEMAP: Handle incompatible operand types
    return { lhs, op_line, op_token, rhs }
  }
}

-- -----------------------------------------------------------------------------
-- Macros
-- -----------------------------------------------------------------------------

local function list(callback, break_token) {
  local list = {}

  repeat {
    table.insert(list, callback() || nil)
  } until !branch(',') || (break_token && current_token.value == break_token)

  return list
}

local function surround(open_char, close_char, callback) {
  expect(open_char, true)
  local result = callback()
  expect(close_char, true)
  return result
}

local function surround_list(open_char, close_char, allow_empty, callback) {
  return surround(open_char, close_char, () -> {
    if current_token.value != close_char || !allow_empty {
      return list(callback, close_char)
    } else {
      return {}
    }
  })
}

-- -----------------------------------------------------------------------------
-- Variables
-- -----------------------------------------------------------------------------

local function name() {
  if current_token.type == TOKEN_TYPES.EOF {
    throw('unexpected eof')
  }

  if current_token.type != TOKEN_TYPES.WORD {
    throw("unexpected token '{ current_token.value }'")
  }

  if KEYWORDS[current_token.value] != nil {
    throw("unexpected keyword '{ current_token.value }'")
  }

  if TERMINALS[current_token.value] != nil {
    throw("unexpected builtin '{ current_token.value }'")
  }

  return consume()
}

local function array_destructure(scope) {
  local compile_lines = {}
  local compile_name = new_tmp_name()
  local declaration_names = {}

  local array_index = 0

  -- SOURCEMAP: Handle destructuring a non-table value
  table.insert(compile_lines, current_token.line)

  surround_list('[', ']', false, () -> {
    array_index += 1

    local declaration_name = name()
    table.insert(declaration_names, declaration_name)

    local assignment_name = get_compile_name(declaration_name, scope)

    table.insert(compile_lines, "{ assignment_name } = { compile_name }[{ array_index }]")

    if branch('=') {
      table.insert(compile_lines, "if { assignment_name } == nil then { assignment_name } = ")
      table.insert(compile_lines, expression())
      table.insert(compile_lines, 'end')
    }
  })

  return {
    compile_lines = compile_lines,
    compile_name = compile_name,
    declaration_names = declaration_names,
  }
}

local function map_destructure(scope) {
  local compile_lines = {}
  local compile_name = new_tmp_name()
  local declaration_names = {}

  -- SOURCEMAP: Handle destructuring a non-table value
  table.insert(compile_lines, current_token.line)

  surround_list('{', '}', false, () -> {
    local key = name()

    local declaration_name = branch(':') && name() || key
    table.insert(declaration_names, declaration_name)

    local assignment_name = get_compile_name(declaration_name, scope)

    if LUA_KEYWORDS[declaration_name] {
      table.insert(compile_lines, "{ assignment_name } = { compile_name }['{ key }']")
    } else {
      table.insert(compile_lines, "{ assignment_name } = { compile_name }.{ key }")
    }

    if branch('=') {
      table.insert(compile_lines, "if { assignment_name } == nil then { assignment_name } = ")
      table.insert(compile_lines, expression())
      table.insert(compile_lines, 'end')
    }
  })

  return {
    compile_lines = compile_lines,
    compile_name = compile_name,
    declaration_names = declaration_names,
  }
}

local function variable(scope = 'local') {
  if current_token.value == '[' {
    return array_destructure(scope)
  } elseif current_token.value == '{' {
    return map_destructure(scope)
  } else {
    return name()
  }
}

-- -----------------------------------------------------------------------------
-- Index Chain
-- -----------------------------------------------------------------------------

local function bracket_index(index_chain_state) {
  -- SOURCEMAP: Handle indexing a non-table
  local compile_lines = { current_token.line, '[', surround('[', ']', expression), ']' }

  index_chain_state.final_base_compile_lines = table.shallowcopy(index_chain_state.compile_lines)
  index_chain_state.final_index_compile_lines = compile_lines

  table.insert(index_chain_state.compile_lines, compile_lines)
}

local function dot_index(index_chain_state) {
  -- SOURCEMAP: Handle indexing a non-table
  local compile_lines = { current_token.line }

  consume() -- '.'

  local key = name()

  if LUA_KEYWORDS[key] {
    table.insert(compile_lines, "['{ key }']" )
  } else {
    table.insert(compile_lines, '.' .. key)
  }

  index_chain_state.final_base_compile_lines = table.shallowcopy(index_chain_state.compile_lines)
  index_chain_state.final_index_compile_lines = compile_lines

  table.insert(index_chain_state.compile_lines, compile_lines)
}

local function method_index(index_chain_state) {
  -- SOURCEMAP: Handle indexing a non-table
  -- SOURCEMAP: Handle calling a non-function value
  -- SOURCEMAP: Handle incompatible argument types
  table.insert(index_chain_state.compile_lines, current_token.line)

  consume() -- ':'

  local method_name = name()

  local method_parameters = surround_list('(', ')', true, expression)

  if !LUA_KEYWORDS[method_name] {
    table.insert(index_chain_state.compile_lines, ":{ method_name }(")
    table.insert(index_chain_state.compile_lines, weave(method_parameters))
    table.insert(index_chain_state.compile_lines, ')')
  } elseif index_chain_state.has_trivial_base && index_chain_state.chain_len == 0 {
    table.insert(index_chain_state.compile_lines, "['{ method_name }'](")

    -- Need to manually insert self, since we are not using the native ':' operator
    table.insert(method_parameters, 1, index_chain_state.base_compile_lines)

    table.insert(index_chain_state.compile_lines, weave(method_parameters))
    table.insert(index_chain_state.compile_lines, ')')
  } else {
    index_chain_state.needs_block_compile = true

    table.insert(index_chain_state.block_compile_lines, index_chain_state.block_compile_name .. '=')
    table.insert(index_chain_state.block_compile_lines, index_chain_state.compile_lines)

    -- Need to manually insert self, since we are not using the native ':' operator
    table.insert(method_parameters, 1, index_chain_state.block_compile_name)

    index_chain_state.compile_lines = {
      "{ index_chain_state.block_compile_name }['{ method_name }'](",
      weave(method_parameters),
      ')',
    }
  }
}

local function function_call_index(index_chain_state) {
  local preceding_compile_lines = index_chain_state.compile_lines
  local preceding_compile_lines_len = #preceding_compile_lines

  while type(preceding_compile_lines[preceding_compile_lines_len]) == 'table' {
    preceding_compile_lines = preceding_compile_lines[preceding_compile_lines_len]
    preceding_compile_lines_len = #preceding_compile_lines
  }

  -- Include function call parens on same line as function name to prevent
  -- parsing errors in Lua5.1
  --    `ambiguous syntax (function call x new statement) near '('`
  preceding_compile_lines[preceding_compile_lines_len] ..= '('

  table.insert(index_chain_state.compile_lines, weave(surround_list('(', ')', true, expression)))
  table.insert(index_chain_state.compile_lines, ')')
}

local function index_chain(options) {
  local block_compile_name = new_tmp_name()

  local index_chain_state = {
    base_compile_lines = options.base_compile_lines,
    compile_lines = { options.base_compile_lines },
    has_trivial_base = options.has_trivial_base,
    chain_len = 0,
    is_function_call = false,

    -- Variables for when we must compile to a Lua block. This is necessary when
    -- compiling a method index with a nontrivial base when the method name is a
    -- Lua keyword, but not an Erde keyword.
    needs_block_compile = false,
    block_compile_name = block_compile_name,
    block_compile_lines = { 'local ' .. block_compile_name },

    -- Variables for tracking the final table in the index chain, along with its
    -- ending index. Useful when the index chain must be referenced multiple
    -- times (such as operator assignments), since repeating the entire chain in compiled code could
    -- potentially be expensive.
    final_base_compile_lines = options.base_compile_lines,
    final_index_compile_lines = {},
  }

  if options.wrap_base_compile_lines {
    table.insert(index_chain_state.compile_lines, 1, '(')
    table.insert(index_chain_state.compile_lines, ')')
  }

  while true {
    -- Use newlines to infer whether the parentheses belong to a function call or the next statement.
    if current_token.value == '(' && current_token.line == tokens[current_token_index - 1].line {
      index_chain_state.is_function_call = true
      function_call_index(index_chain_state)
    } elseif current_token.value == '[' {
      index_chain_state.is_function_call = false
      bracket_index(index_chain_state)
    } elseif current_token.value == '.' {
      index_chain_state.is_function_call = false
      dot_index(index_chain_state)
    } elseif current_token.value == ':' {
      index_chain_state.is_function_call = true
      method_index(index_chain_state)
    } else {
      break
    }

    index_chain_state.chain_len += 1
  }

  if options.require_chain && index_chain_state.chain_len == 0 {
    if current_token.type == TOKEN_TYPES.EOF {
      throw('unexpected eof')
    } else {
      throw("unexpected token '{ current_token.value }'")
    }
  }

  if index_chain_state.chain_len == 0 {
    -- Unwrap `index_chain_state.compile_lines` if there is no chain, especially
    -- if we added parentheses w/ `options.wrap_base_compile_lines`
    index_chain_state.compile_lines = options.base_compile_lines
  }

  return index_chain_state
}

-- -----------------------------------------------------------------------------
-- Strings
-- -----------------------------------------------------------------------------

local function single_quote_string() {
  consume() -- "'"

  if current_token.type == TOKEN_TYPES.SINGLE_QUOTE_STRING {
    -- SOURCEMAP: expression
    return { current_token.line, "'" .. consume() }
  } else {
    -- SOURCEMAP: expression
    return { current_token.line, "'" .. consume() .. consume() }
  }
}

local function double_quote_string() {
  local double_quote_string_line = current_token.line

  local has_interpolation = false

  consume() -- '"'

  if current_token.type == TOKEN_TYPES.DOUBLE_QUOTE_STRING {
    -- Handle empty string case exceptionally so we can make assumptions at the
    -- end to simplify excluding empty string concatenations.

    -- SOURCEMAP: expression
    return { double_quote_string_line, '"' .. consume() }, has_interpolation
  }

  local compile_lines = {}
  local content = ''

  repeat {
    if current_token.type == TOKEN_TYPES.INTERPOLATION {
      has_interpolation = true

      if content != '' { -- only if nonempty
        table.insert(compile_lines, '"' .. content .. '"')
      }

      table.insert(compile_lines, { 'tostring(', surround('{', '}', expression), ')' })

      content = ''
    } else {
      content ..= consume()
    }
  } until current_token.type == TOKEN_TYPES.DOUBLE_QUOTE_STRING

  if content != '' { -- only if nonempty
    table.insert(compile_lines, '"' .. content .. '"')
  }

  consume() -- '"'

  -- SOURCEMAP: expression
  return { double_quote_string_line, weave(compile_lines, '..') }, has_interpolation
}

local function block_string() {
  local block_string_line = current_token.line

  local has_interpolation = false

  local start_quote = '[' .. current_token.equals .. '['
  local end_quote = ']' .. current_token.equals .. ']'

  consume() -- `start_quote`

  if current_token.type == TOKEN_TYPES.BLOCK_STRING {
    -- Handle empty string case exceptionally so we can make assumptions at the
    -- end to simplify excluding empty string concatenations.

    consume() -- `end_quote`

    -- SOURCEMAP: expression
    return { block_string_line, start_quote .. end_quote }, has_interpolation
  }

  local compile_lines = {}
  local content = ''

  repeat {
    if current_token.type == TOKEN_TYPES.INTERPOLATION {
      has_interpolation = true

      if content != '' { -- only if nonempty
        table.insert(compile_lines, start_quote .. content .. end_quote)
      }

      table.insert(compile_lines, { 'tostring(', surround('{', '}', expression), ')' })
      content = ''

      if current_token.value:sub(1, 1) == '\n' {
        -- Lua ignores the first character in block strings when it is a
        -- newline! We need to make sure we preserve any newline following
        -- an interpolation by inserting a second newline in the compiled code.
        -- @see http://www.lua.org/pil/2.4.html
        content ..= '\n' .. consume()
      }
    } else {
      content ..= consume()
    }
  } until current_token.type == TOKEN_TYPES.BLOCK_STRING

  if content != '' { -- only if nonempty
    table.insert(compile_lines, start_quote .. content .. end_quote)
  }

  consume() -- `end_quote`

  -- SOURCEMAP: expression
  return { block_string_line, weave(compile_lines, '..') }, has_interpolation
}

-- -----------------------------------------------------------------------------
-- Tables
-- -----------------------------------------------------------------------------

local function table_constructor() {
  local table_constructor_line = current_token.line
  local compile_lines = {}

  surround_list('{', '}', true, () -> {
    local next_token = tokens[current_token_index + 1]

    if current_token.value == '[' {
      table.insert(compile_lines, '[')
      table.insert(compile_lines, surround('[', ']', expression))
      table.insert(compile_lines, ']')
      table.insert(compile_lines, expect('=', true))
    } elseif next_token.type == TOKEN_TYPES.SYMBOL && next_token.value == '=' {
      local key = name()

      if LUA_KEYWORDS[key] {
        table.insert(compile_lines, "['{ key }']" .. consume())
      } else {
        table.insert(compile_lines, key .. consume())
      }
    }

    table.insert(compile_lines, expression())
    table.insert(compile_lines, ',')
  })

  -- SOURCEMAP: expression
  return { table_constructor_line, '{', compile_lines, '}' }
}

-- -----------------------------------------------------------------------------
-- Returns
-- -----------------------------------------------------------------------------

local function return_list() {
  local look_ahead_limit_token, look_ahead_limit_token_index = look_past_surround()

  if look_ahead_limit_token.value == '->' || look_ahead_limit_token.value == '=>' {
    return arrow_function()
  }

  local look_ahead_token_index = current_token_index + 1
  local look_ahead_token = tokens[look_ahead_token_index]

  while look_ahead_token_index < look_ahead_limit_token_index {
    -- Check token type, since we are bypassing all parsing structure here and
    -- need to be careful for arbitrary string contents.
    if look_ahead_token.type == TOKEN_TYPES.SYMBOL && SURROUND_ENDS[look_ahead_token.value] {
      look_ahead_token, look_ahead_token_index = look_past_surround(look_ahead_token_index)
    } elseif look_ahead_token.type == TOKEN_TYPES.SYMBOL && look_ahead_token.value == ',' {
      return weave(surround_list('(', ')', false, expression))
    } else {
      look_ahead_token_index += 1
      look_ahead_token = tokens[look_ahead_token_index]
    }
  }

  return expression()
}

local function block_return() {
  if is_module_return_block {
    module_return_line = current_token.line
  }

  local compile_lines = { consume() }

  if block_depth == 1 {
    if current_token.type != TOKEN_TYPES.EOF {
      if current_token.value == '(' {
        table.insert(compile_lines, return_list())
      } else {
        table.insert(compile_lines, weave(list(expression)))
      }
    }

    if current_token.type != TOKEN_TYPES.EOF {
      throw("expected '<eof>', got '{ current_token.value }'")
    }
  } else {
    if current_token.value != '}' {
      if current_token.value == '(' {
        table.insert(compile_lines, return_list())
      } else {
        table.insert(compile_lines, weave(list(expression)))
      }
    }

    if current_token.value != '}' {
      throw("expected '}', got '{ current_token.value }'")
    }
  }

  return compile_lines
}

-- -----------------------------------------------------------------------------
-- Functions
-- -----------------------------------------------------------------------------

local function parameters() {
  local compile_lines = {}
  local compile_names = {}
  local has_varargs = false

  surround_list('(', ')', true, () -> {
    if branch('...') {
      has_varargs = true

      table.insert(compile_names, '...')

      if current_token.type == TOKEN_TYPES.WORD {
        local varargs_name = name()
        table.insert(compile_lines, "local { get_compile_name(varargs_name) } = \{ ... }")
        add_block_declaration(varargs_name, 'local', block_depth + 1)
      }

      branch(',')
      expect(')')
    } else {
      local var = variable()

      add_block_declaration(var, 'local', block_depth + 1)

      local compile_name = type(var) == 'string' && get_compile_name(var) || var.compile_name
      table.insert(compile_names, compile_name)

      if branch('=') {
        table.insert(compile_lines, "if { compile_name } == nil then { compile_name } = ")
        table.insert(compile_lines, expression())
        table.insert(compile_lines, 'end')
      }

      if type(var) == 'table' {
        table.insert(compile_lines, 'local ' .. table.concat(table.map(var.declaration_names, get_compile_name), ','))
        table.insert(compile_lines, var.compile_lines)
      }
    }
  })

  return {
    compile_lines = compile_lines,
    compile_names = compile_names,
    has_varargs = has_varargs,
  }
}

local function function_block() {
  local old_is_module_return_block = is_module_return_block
  local old_break_name = break_name

  is_module_return_block = false
  break_name = nil

  local compile_lines = block()

  is_module_return_block = old_is_module_return_block
  break_name = old_break_name

  return compile_lines
}

function arrow_function() {
  local old_is_varargs_block = is_varargs_block

  local arrow_function_line = current_token.line
  local param_compile_lines = {}
  local param_compile_names = {}

  if current_token.value == '(' {
    local params = parameters()
    table.insert(param_compile_lines, params.compile_lines)
    is_varargs_block = params.has_varargs
    param_compile_names = params.compile_names
  } else {
    is_varargs_block = false

    local var = variable()

    add_block_declaration(var, 'local', block_depth + 1)

    if type(var) == 'string' {
      table.insert(param_compile_names, get_compile_name(var))
    } else {
      table.insert(param_compile_names, var.compile_name)
      table.insert(param_compile_lines, 'local ' .. table.concat(table.map(var.declaration_names, get_compile_name), ','))
      table.insert(param_compile_lines, var.compile_lines)
    }
  }

  if current_token.value == '->' {
    consume()
  } elseif current_token.value == '=>' {
    table.insert(param_compile_names, 1, 'self')
    consume()
  } elseif current_token.type == TOKEN_TYPES.EOF {
    throw("unexpected eof (expected '->' or '=>')")
  } else {
    throw("unexpected token '{ current_token.value }' (expected '->' or '=>')")
  }

  local compile_lines = {
    arrow_function_line, -- SOURCEMAP: expression
    "function({ table.concat(param_compile_names, ',') })",
    param_compile_lines,
  }

  if current_token.value == '{' {
    table.insert(compile_lines, surround('{', '}', function_block))
  } else {
    table.insert(compile_lines, 'return')

    -- Update block variables manually for the return expressions
    local old_block_declarations = block_declarations

    block_depth += 1
    block_declaration_stack[block_depth] ||= {}
    block_declarations = block_declaration_stack[block_depth]

    if current_token.value == '(' {
      table.insert(compile_lines, return_list())
    } else {
      table.insert(compile_lines, expression())
    }

    block_declarations = old_block_declarations
    block_declaration_stack[block_depth] = nil
    block_depth -= 1
  }

  table.insert(compile_lines, 'end')

  is_varargs_block = old_is_varargs_block

  return compile_lines
}

local function function_signature(scope) {
  local base_name = name()

  if (current_token.value == '.' || current_token.value == ':') && scope != nil {
    -- Lua does not allow scope for table functions (ex. `local function a.b()`)
    throw('cannot use scopes for table values', current_token.line)
  }

  if scope == 'module' || scope == 'global' {
    block_declarations[base_name] = scope
  }

  local signature = get_compile_name(base_name, scope || block_declarations[base_name])
  local needs_label_assignment = false
  local needs_self_injection = false

  while branch('.') {
    local key = name()

    if LUA_KEYWORDS[key] {
      needs_label_assignment = true
      signature ..= "['{ key }']"
    } else {
      signature ..= '.' .. key
    }
  }

  if branch(':') {
    local key = name()

    if LUA_KEYWORDS[key] {
      needs_label_assignment = true
      needs_self_injection = true
      signature ..= "['{ key }']"
    } else {
      signature ..= ':' .. key
    }
  }

  return {
    signature = signature,
    needs_label_assignment = needs_label_assignment,
    needs_self_injection = needs_self_injection,
  }
}

local function function_declaration(scope) {
  -- SOURCEMAP: Handle indexing a non-table
  -- Note that Lua always returns the line of the function declaration in this
  -- case, not the line of the index
  local compile_lines = { current_token.line }

  consume() -- 'function'

  local {
    signature,
    needs_label_assignment,
    needs_self_injection,
  } = function_signature(scope)

  if scope == 'local' {
    table.insert(compile_lines, 'local')
  }

  if needs_label_assignment {
    table.insert(compile_lines, signature)
    table.insert(compile_lines, '=')
    table.insert(compile_lines, 'function')
  } else {
    table.insert(compile_lines, 'function')
    table.insert(compile_lines, signature)
  }

  local params = parameters()

  if needs_self_injection {
    table.insert(params.compile_names, 'self')
  }

  table.insert(compile_lines, '(' .. table.concat(params.compile_names, ',') .. ')')
  table.insert(compile_lines, params.compile_lines)

  local old_is_varargs_block = is_varargs_block
  is_varargs_block = params.has_varargs
  table.insert(compile_lines, surround('{', '}', function_block))
  is_varargs_block = old_is_varargs_block

  table.insert(compile_lines, 'end')

  return compile_lines
}

-- -----------------------------------------------------------------------------
-- Expressions
-- -----------------------------------------------------------------------------

local function index_chain_expression(options) {
  local index_chain = index_chain(options)

  if index_chain.needs_block_compile {
    return {
      '(function()',
      index_chain.block_compile_lines,
      'return',
      index_chain.compile_lines,
      'end)()',
    }
  } else {
    return index_chain.compile_lines
  }
}

local function terminal_expression() {
  if current_token.type == TOKEN_TYPES.NUMBER {
    -- SOURCEMAP: expression
    return { current_token.line, consume() }
  } elseif current_token.type == TOKEN_TYPES.SINGLE_QUOTE_STRING {
    return index_chain_expression({
      base_compile_lines = single_quote_string(),
      has_trivial_base = true,
      wrap_base_compile_lines = true,
    })
  } elseif current_token.type == TOKEN_TYPES.DOUBLE_QUOTE_STRING {
    local compile_lines, has_interpolation = double_quote_string()
    return index_chain_expression({
      base_compile_lines = compile_lines,
      has_trivial_base = !has_interpolation,
      wrap_base_compile_lines = true,
    })
  } elseif current_token.type == TOKEN_TYPES.BLOCK_STRING {
    local compile_lines, has_interpolation = block_string()
    return index_chain_expression({
      base_compile_lines = compile_lines,
      has_trivial_base = !has_interpolation,
      wrap_base_compile_lines = true,
    })
  }

  if TERMINALS[current_token.value] {
    if current_token.value == '...' && !is_varargs_block {
      throw("cannot use '...' outside a vararg function")
    }

    -- SOURCEMAP: expression
    return { current_token.line, consume() }
  }

  local next_token = tokens[current_token_index + 1]
  local is_arrow_function = (
    next_token.type == TOKEN_TYPES.SYMBOL &&
    (next_token.value == '->' || next_token.value == '=>')
  )

  -- First do a quick check for is_arrow_function (in case of implicit params),
  -- otherwise if surround_end is truthy (possible params), need to check the
  -- next token after. This is _much_ faster than backtracking.
  if !is_arrow_function && SURROUND_ENDS[current_token.value] {
    local past_surround_token = look_past_surround()
    is_arrow_function = (
      past_surround_token.type == TOKEN_TYPES.SYMBOL &&
      (past_surround_token.value == '->' || past_surround_token.value == '=>')
    )
  }

  if is_arrow_function {
    return arrow_function()
  } elseif current_token.value == '{' {
    return table_constructor()
  } elseif current_token.value == '(' {
    return index_chain_expression({
      -- SOURCEMAP: expression
      base_compile_lines = { current_token.line, '(', surround('(', ')', expression), ')' },
    })
  } else {
    local base_name_line, base_name = current_token.line, name()

    return index_chain_expression({
      -- SOURCEMAP: expression
      base_compile_lines = { base_name_line, get_compile_name(base_name, block_declarations[base_name]) },
      has_trivial_base = true,
    })
  }
}

local function unop_expression() {
  local unop_line, unop = current_token.line, UNOPS[consume()]

  local operand = expression(unop.prec + 1)

  if unop.token == '!' {
    return { 'not', operand }
  } elseif unop.token != '~' {
    -- SOURCEMAP: Handle incompatible operand types
    return { unop_line, unop.token, operand }
  } elseif bitlib {
    -- NOTE: We wrap the bitlib call in parentheses to prevent tail calls in
    -- LuaJIT, since any errors will have a misleading stacktrace.
    -- see: https://www.freelists.org/post/luajit/Bad-stack-trace-from-lua-getstack-and-lua-getinfo,1
    --
    -- SOURCEMAP: Handle incompatible argument types
    return { unop_line, "(require('{ bitlib }').bnot(", operand, '))' }
  } elseif lua_target == '5.1+' || lua_target == '5.2+' {
    throw('must specify bitlib for compiling bit operations when targeting 5.1+ or 5.2+', unop_line)
  } else {
    -- SOURCEMAP: Handle incompatible operand types
    return { unop_line, unop.token, operand }
  }
}

function expression(min_prec = 1) {
  if current_token.type == TOKEN_TYPES.EOF {
    throw('unexpected eof (expected expression)')
  }

  local compile_lines = UNOPS[current_token.value] && unop_expression() || terminal_expression()

  local binop_line, binop = current_token.line, BINOPS[current_token.value]

  while binop && binop.prec >= min_prec {
    if BITOPS[binop.token] && (lua_target == '5.1+' || lua_target == '5.2+') && !bitlib {
      throw('must specify bitlib for compiling bit operations when targeting 5.1+ or 5.2+', binop_line)
    }

    consume()

    if binop.token == '~' && current_token.value == '=' {
      throw("unexpected token '~=', did you mean '!='?")
    }

    local operand = binop.assoc == LEFT_ASSOCIATIVE
      && expression(binop.prec + 1)
      || expression(binop.prec)

    compile_lines = compile_binop(binop.token, binop_line, compile_lines, operand)

    binop_line, binop = current_token.line, BINOPS[current_token.value]
  }

  return compile_lines
}

-- -----------------------------------------------------------------------------
-- Blocks
-- -----------------------------------------------------------------------------

function block() {
  local old_block_declarations = block_declarations

  block_depth += 1
  block_declaration_stack[block_depth] ||= table.shallowcopy(block_declaration_stack[block_depth - 1])
  block_declarations = block_declaration_stack[block_depth]

  local compile_lines = {}

  while current_token.value != '}' {
    table.insert(compile_lines, statement())
  }

  block_declarations = old_block_declarations
  block_declaration_stack[block_depth] = nil
  block_depth -= 1

  return compile_lines
}

local function do_block() {
  return {
    consume(), -- 'do'
    surround('{', '}', block),
    'end',
  }
}

-- -----------------------------------------------------------------------------
-- Loops
-- -----------------------------------------------------------------------------

local function loop_block() {
  local old_break_name = break_name
  local old_has_continue = has_continue

  break_name = new_tmp_name()
  has_continue = false

  local compile_lines = block()

  if has_continue {
    if lua_target == '5.1' || lua_target == '5.1+' {
      table.insert(compile_lines, 1, "local { break_name } = true repeat")
      table.insert(compile_lines, "{ break_name } = false until true if { break_name } then break end")
    } else {
      table.insert(compile_lines, "::{ break_name }::")
    }
  }

  break_name = old_break_name
  has_continue = old_has_continue

  return compile_lines
}

local function loop_break() {
  consume()

  if break_name == nil {
    throw("cannot use 'break' outside of loop")
  }

  -- Lua 5.1 / LuaJIT do not allow code to appear in the same block following
  -- a `break` statement (similar to `return`)
  if lua_target == '5.1' || lua_target == '5.1+' || lua_target == 'jit' {
    if current_token.value != '}' {
      throw("expected '}', got '{ current_token.value }'")
    }
  }

  return 'break'
}

local function loop_continue() {
  if break_name == nil {
    throw("cannot use 'continue' outside of loop")
  }

  has_continue = true
  consume()

  if lua_target == '5.1' || lua_target == '5.1+' {
    -- Place `break` in its own block! Lua 5.1 / LuaJIT do not allow code to
    -- appear in the same block following a `break` statement (similar to `return`)
    return "{ break_name } = false do break end"
  } else {
    return "goto { break_name }"
  }
}

local function for_loop() {
  local compile_lines = {}
  local pre_body_compile_lines = {}

  table.insert(compile_lines, consume()) -- 'for'

  local next_token = tokens[current_token_index + 1]

  if next_token.type == TOKEN_TYPES.SYMBOL && next_token.value == '=' {
    local loop_name = name()

    add_block_declaration(loop_name, 'local', block_depth + 1)

    table.insert(compile_lines, get_compile_name(loop_name) .. consume())

    local expressions_line = current_token.line
    local expressions = list(expression)
    local num_expressions = #expressions

    if num_expressions != 2 && num_expressions != 3 {
      throw("invalid numeric for, expected 2-3 expressions, got { num_expressions }", expressions_line)
    }

    table.insert(compile_lines, weave(expressions))
  } else {
    local names = {}

    for _, var in ipairs(list(variable)) {
      add_block_declaration(var, 'local', block_depth + 1)

      if type(var) == 'string' {
        table.insert(names, get_compile_name(var))
      } else {
        table.insert(names, var.compile_name)
        table.insert(pre_body_compile_lines, 'local ' .. table.concat(table.map(var.declaration_names, get_compile_name), ','))
        table.insert(pre_body_compile_lines, var.compile_lines)
      }
    }

    table.insert(compile_lines, weave(names))
    table.insert(compile_lines, expect('in', true))
    table.insert(compile_lines, weave(list(expression)))
  }

  table.insert(compile_lines, 'do')
  table.insert(compile_lines, pre_body_compile_lines)
  table.insert(compile_lines, surround('{', '}', loop_block))
  table.insert(compile_lines, 'end')

  return compile_lines
}

local function repeat_until() {
  return {
    consume(), -- 'repeat'
    surround('{', '}', loop_block),
    expect('until', true),
    expression(),
  }
}

local function while_loop() {
  return {
    consume(), -- 'while'
    expression(),
    'do',
    surround('{', '}', loop_block),
    'end',
  }
}

-- -----------------------------------------------------------------------------
-- Jumps
-- -----------------------------------------------------------------------------

local function goto_jump() {
  if lua_target == '5.1' || lua_target == '5.1+' {
    throw("'goto' statements only compatibly with lua targets 5.2+, jit")
  }

  consume() -- 'goto'

  local label_line, label = current_token.line, name()
  table.insert(goto_jumps, { label = label, line = label_line })

  return 'goto ' .. get_compile_name(label)
}

local function goto_label() {
  if lua_target == '5.1' || lua_target == '5.1+' {
    throw("'goto' statements only compatibly with lua targets 5.2+, jit")
  }

  consume() -- '::'

  local label = name()
  goto_labels[label] = true

  return '::' .. get_compile_name(label) .. expect('::', true)
}

local function if_else() {
  local compile_lines = {}

  table.insert(compile_lines, consume()) -- 'if'
  table.insert(compile_lines, expression())
  table.insert(compile_lines, 'then')
  table.insert(compile_lines, surround('{', '}', block))

  while current_token.value == 'elseif' {
    table.insert(compile_lines, consume())
    table.insert(compile_lines, expression())
    table.insert(compile_lines, 'then')
    table.insert(compile_lines, surround('{', '}', block))
  }

  if current_token.value == 'else' {
    table.insert(compile_lines, consume())

    if current_token.value == 'if' {
      throw("unexpected tokens 'else if', did you mean 'elseif'?")
    }

    table.insert(compile_lines, surround('{', '}', block))
  }

  table.insert(compile_lines, 'end')

  return compile_lines
}

-- -----------------------------------------------------------------------------
-- Assignments
-- -----------------------------------------------------------------------------

local function assignment_index_chain() {
  if current_token.value == '(' {
    return index_chain({
      base_compile_lines = { current_token.line, '(', surround('(', ')', expression), ')' },
      require_chain = true,
    })
  } else {
    local base_name_line, base_name = current_token.line, name()

    return index_chain({
      base_compile_lines = { base_name_line, get_compile_name(base_name, block_declarations[base_name]) },
      has_trivial_base = true,
    })
  }
}

local function non_operator_assignment(ids, expressions) {
  local assignment_ids = {}
  local assignment_block_compile_names = {}
  local assignment_block_compile_lines = {}

  for _, id in ipairs(ids) {
    if !id.needs_block_compile {
      table.insert(assignment_ids, id.compile_lines)
    } else {
      local assignment_name = new_tmp_name()

      table.insert(assignment_ids, assignment_name)
      table.insert(assignment_block_compile_names, assignment_name)

      table.insert(assignment_block_compile_lines, id.block_compile_lines)
      table.insert(assignment_block_compile_lines, id.compile_lines)
      table.insert(assignment_block_compile_lines, '=' .. assignment_name)
    }
  }

  local compile_lines = {}

  if #assignment_block_compile_names > 0 {
    table.insert(compile_lines, 'local')
    table.insert(compile_lines, weave(assignment_block_compile_names))
  }

  table.insert(compile_lines, weave(assignment_ids))
  table.insert(compile_lines, '=')
  table.insert(compile_lines, weave(expressions))
  table.insert(compile_lines, assignment_block_compile_lines)

  return compile_lines
}

local function single_operator_assignment(id, expr, op_token, op_line) {
  local compile_lines = {}
  local id_compile_lines = id.compile_lines

  if id.needs_block_compile {
    table.insert(compile_lines, id.block_compile_lines)
  }

  if !id.has_trivial_base || id.chain_len > 1 {
    local final_base_name = new_tmp_name()

    table.insert(compile_lines, "local { final_base_name } =")
    table.insert(compile_lines, id.final_base_compile_lines)

    id_compile_lines = { final_base_name, id.final_index_compile_lines }
  }

  table.insert(compile_lines, id_compile_lines)
  table.insert(compile_lines, '=')

  if type(expr) == 'table' {
    -- Escape expression w/ parens in case the expression has operators that
    -- fight the assignment operator's precedence.
    -- Ex. `mystring ..= true && 'a' || 'b'`
    expr = { '(', expr, ')' }
  }

  table.insert(compile_lines, compile_binop(op_token, op_line, id_compile_lines, expr))

  return compile_lines
}

local function operator_assignment(ids, expressions, op_token, op_line) {
  if #ids == 1 {
    return single_operator_assignment(ids[1], expressions[1], op_token, op_line)
  }

  local assignment_names = {}
  local assignment_compile_lines = {}

  for _, id in ipairs(ids) {
    local assignment_name = new_tmp_name()
    table.insert(assignment_names, assignment_name)
    table.insert(assignment_compile_lines, single_operator_assignment(id, assignment_name, op_token, op_line))
  }

  return {
    "local { table.concat(assignment_names, ',') } =",
    weave(expressions),
    assignment_compile_lines
  }
}

local function variable_assignment(first_id) {
  local ids = { first_id }

  while branch(',') {
    local id_line, id = current_token.line, assignment_index_chain()

    if id.is_function_call {
      throw('cannot assign value to function call', id_line)
    }

    table.insert(ids, id)
  }

  local op_line, op_token = current_token.line, BINOP_ASSIGNMENT_TOKENS[current_token.value] && consume()

  if BITOPS[op_token] && (lua_target == '5.1+' || lua_target == '5.2+') && !bitlib {
    throw('must specify bitlib for compiling bit operations when targeting 5.1+ or 5.2+', op_line)
  }

  expect('=', true)
  local expressions = list(expression)

  if op_token {
    return operator_assignment(ids, expressions, op_token, op_line)
  } else {
    return non_operator_assignment(ids, expressions)
  }
}

-- -----------------------------------------------------------------------------
-- Declarations
-- -----------------------------------------------------------------------------

local function variable_declaration(scope) {
  local assignment_names = {}

  local has_destructure = false
  local destructure_declaration_names = {}
  local destructure_compile_lines = {}

  for _, var in ipairs(list(() -> variable(scope))) {
    add_block_declaration(var, scope)

    if type(var) == 'string' {
      table.insert(assignment_names, get_compile_name(var, scope))
    } else {
      has_destructure = true

      table.insert(assignment_names, var.compile_name)
      table.insert(destructure_compile_lines, var.compile_lines)

      if scope == 'local' {
        table.merge(destructure_declaration_names, table.map(var.declaration_names, get_compile_name))
      } else {
        table.insert(destructure_declaration_names, var.compile_name)
      }
    }
  }

  if has_destructure {
    expect('=', true)
  } elseif scope == 'local' && current_token.value != '=' {
    return 'local ' .. table.concat(assignment_names, ',')
  } elseif !branch('=') {
    return '' -- nothing to do
  }

  local compile_lines = {}

  if has_destructure {
    table.insert(compile_lines, 'local ' .. table.concat(destructure_declaration_names, ','))
  }

  if scope == 'local' {
    table.insert(compile_lines, 'local')
  }

  table.insert(compile_lines, table.concat(assignment_names, ',') .. '=')
  table.insert(compile_lines, weave(list(expression)))
  table.insert(compile_lines, destructure_compile_lines)

  return compile_lines
}

-- -----------------------------------------------------------------------------
-- Statement
-- -----------------------------------------------------------------------------

function statement() {
  local compile_lines = {}

  if current_token.value == 'break' {
    table.insert(compile_lines, loop_break())
  } elseif current_token.value == 'continue' {
    table.insert(compile_lines, loop_continue())
  } elseif current_token.value == 'goto' {
    table.insert(compile_lines, goto_jump())
  } elseif current_token.value == '::' {
    table.insert(compile_lines, goto_label())
  } elseif current_token.value == 'do' {
    table.insert(compile_lines, do_block())
  } elseif current_token.value == 'if' {
    table.insert(compile_lines, if_else())
  } elseif current_token.value == 'for' {
    table.insert(compile_lines, for_loop())
  } elseif current_token.value == 'while' {
    table.insert(compile_lines, while_loop())
  } elseif current_token.value == 'repeat' {
    table.insert(compile_lines, repeat_until())
  } elseif current_token.value == 'return' {
    table.insert(compile_lines, block_return())
  } elseif current_token.value == 'function' {
    table.insert(compile_lines, function_declaration())
  } elseif current_token.value == 'local' || current_token.value == 'global' || current_token.value == 'module' {
    local scope_line, scope = current_token.line, consume()

    if scope == 'module' {
      if block_depth > 1 {
        throw('module declarations must appear at the top level', scope_line)
      }

      has_module_declarations = true
    }

    if current_token.value == 'function' {
      table.insert(compile_lines, function_declaration(scope))
    } else {
      table.insert(compile_lines, variable_declaration(scope))
    }
  } else {
    local chain = assignment_index_chain()

    if !chain.is_function_call {
      table.insert(compile_lines, variable_assignment(chain))
    } elseif chain.needs_block_compile {
      table.insert(compile_lines, 'do')
      table.insert(compile_lines, chain.block_compile_lines)
      table.insert(compile_lines, chain.compile_lines)
      table.insert(compile_lines, 'end')
    } else {
      table.insert(compile_lines, chain.compile_lines)
    }
  }

  if current_token.value == ';' {
    table.insert(compile_lines, consume())
  } elseif current_token.value == '(' {
    table.insert(compile_lines, ';') -- Add semi-colon to prevent ambiguous Lua code
  }

  return compile_lines
}

-- -----------------------------------------------------------------------------
-- Module
-- -----------------------------------------------------------------------------

local function module_block() {
  local compile_lines = {}

  block_declarations = {}
  block_declaration_stack[block_depth] = block_declarations

  if current_token.type == TOKEN_TYPES.SHEBANG {
    table.insert(compile_lines, consume())
  }

  while current_token.type != TOKEN_TYPES.EOF {
    table.insert(compile_lines, statement())
  }

  if has_module_declarations {
    if module_return_line != nil {
      throw("cannot use 'return' w/ 'module' declarations", module_return_line)
    }

    table.insert(compile_lines, 1, 'local _MODULE = {}')
    table.insert(compile_lines, 'return _MODULE')
  }

  return compile_lines
}

-- -----------------------------------------------------------------------------
-- Main
-- -----------------------------------------------------------------------------

local function collect_compile_lines(lines, state) {
  for _, line in ipairs(lines) {
    if type(line) == 'number' {
      -- Keep track of the last known source line and assign it to compiled lines
      -- with no source. We do this because Lua may give an error at the line of the
      -- _next_ token in certain cases. For example, the following will give an
      -- error at line 3, instead of line 2 where the nil index actually occurs:
      --   local x = nil
      --   print(x.a
      --   )
      state.source_line = line
    } elseif type(line) == 'string' {
      table.insert(state.compile_lines, line)
      table.insert(state.source_map, state.source_line)
    } else {
      collect_compile_lines(line, state)
    }
  }
}

return (source, options = {}) -> {
  tokens = tokenize(source, options.alias)
  current_token_index = 1
  current_token = tokens[current_token_index]
  block_depth = 1
  tmp_name_counter = 1
  break_name = nil
  has_continue = false
  has_module_declarations = false
  is_module_return_block = true
  module_return_line = nil
  is_varargs_block = true
  block_declarations = {}
  block_declaration_stack = {}
  goto_jumps = {}
  goto_labels = {}
  alias = options.alias || get_source_alias(source)
  lua_target = options.lua_target || config.lua_target
  bitlib = options.bitlib || config.bitlib
    || (lua_target == '5.1' && 'bit') -- Mike Pall's LuaBitOp
    || (lua_target == 'jit' && 'bit') -- Mike Pall's LuaBitOp
    || (lua_target == '5.2' && 'bit32') -- Lua 5.2's builtin bit32 library

  local source_map = {}
  local compile_lines = {}

  collect_compile_lines(module_block(), {
    compile_lines = compile_lines,
    source_map = source_map,
    source_line = current_token.line,
  })

  for _, { label, line } in ipairs(goto_jumps) {
    if goto_labels[label] == nil {
      throw("failed to find goto label '{ label }'", line)
    }
  }

  table.insert(compile_lines, "-- Compiled with Erde { VERSION } w/ Lua target { lua_target }")
  table.insert(compile_lines, COMPILED_FOOTER_COMMENT)

  return table.concat(compile_lines, '\n'), source_map
}
