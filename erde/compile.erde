local config = require('erde.config')
local {
  BINOP_ASSIGNMENT_TOKENS,
  BINOPS,
  BITOPS,
  BITLIB_METHODS,
  COMPILED_FOOTER_COMMENT,
  DIGIT,
  KEYWORDS,
  LEFT_ASSOCIATIVE,
  LUA_KEYWORDS,
  SURROUND_ENDS,
  TERMINALS,
  TOKEN_TYPES,
  UNOPS,
  VERSION,
} = require('erde.constants')
local tokenize = require('erde.tokenize')
local { get_source_alias } = require('erde.utils')

local unpack = table.unpack || unpack

-- Foward declare
local expression, block, statement

-- -----------------------------------------------------------------------------
-- State
-- -----------------------------------------------------------------------------

-- Tokenization results.
local tokens

-- The index in `tokens` of the current token we are processing.
local current_token_index

-- The current token we are processing. Always equivalent to
-- `tokens[current_token_index]`.
local current_token

-- Current block depth during parsing
local block_depth

-- Counter for generating unique names in compiled code.
local tmp_name_counter

-- Break name to use for `continue` statements. This is also used to validate
-- the context of `break` and `continue`.
local break_name

-- Flag to keep track of whether the current block has any `continue` statements.
local has_continue

-- Keeps track of whether the module has any `module` declarations.
local has_module_declarations

-- Keeps track of whether the module has a `return` statement. Used to warn the
-- developer if they try to combine `return` with `module` scopes.
local is_module_return_block, module_return_line

-- Keeps track of whether the current block can use varargs as an expression.
-- Required since the Lua _parser_ will throw an error if varargs are used
-- outside a vararg function.
local is_varargs_block

-- Name for the current source being compiled (used in error messages)
local alias

-- Lua targets to support when generating compiled code.
local lua_target

-- Resolved bit library to use for compiling bit operations.
local bitlib

-- -----------------------------------------------------------------------------
-- General Helpers
-- -----------------------------------------------------------------------------

local function throw(message, line = current_token.line) {
  -- Use error level 0 since we already include alias
  error("{ alias }:{ line }: { message }", 0)
}

-- -----------------------------------------------------------------------------
-- Parse Helpers
-- -----------------------------------------------------------------------------

local function consume() {
  local consumed_token_value = current_token.value
  current_token_index += 1
  current_token = tokens[current_token_index]
  return consumed_token_value
}

local function branch(token) {
  if token == current_token.value {
    consume()
    return true
  }
}

local function ensure(is_valid, message) {
  if !is_valid {
    throw(message)
  }
}

local function expect(token, prevent_consume) {
  ensure(current_token.value != nil, "unexpected eof (expected { token })")
  ensure(token == current_token.value, "expected '{ token }' got '{ current_token.value }'")
  if !prevent_consume { return consume() }
}

local function look_ahead(n) {
  local token = tokens[current_token_index + n]
  return token && token.value || nil
}

local function look_past_surround(token_start_index = current_token_index) {
  local surround_start = tokens[token_start_index].value
  local surround_end = SURROUND_ENDS[surround_start]
  local surround_depth = 1

  local look_ahead_token_index = token_start_index + 1
  local look_ahead_token = tokens[look_ahead_token_index].value

  while surround_depth > 0 {
    if look_ahead_token == nil {
      throw(
        "unexpected eof, missing ending '{ surround_end }' for '{ surround_start }' at [{ tokens[token_start_index].line }]",
        tokens[look_ahead_token_index - 1].line,
      )
    } elseif look_ahead_token == surround_start {
      surround_depth += 1
    } elseif look_ahead_token == surround_end {
      surround_depth -= 1
    }

    look_ahead_token_index += 1
    look_ahead_token = tokens[look_ahead_token_index] && tokens[look_ahead_token_index].value || nil
  }

  return look_ahead_token, look_ahead_token_index
}

-- -----------------------------------------------------------------------------
-- Compile Helpers
-- -----------------------------------------------------------------------------

local function new_tmp_name() {
  tmp_name_counter += 1
  return "__ERDE_TMP_{ tmp_name_counter }__"
}

local function weave(t, separator = ',') {
  local woven = {}
  local len = #t

  for i = 1, len - 1 {
    table.insert(woven, t[i])
    if type(t[i]) != 'number' {
      table.insert(woven, separator)
    }
  }

  table.insert(woven, t[len])
  return woven
}

local function compile_binop(token, line, lhs, rhs) {
  if bitlib && BITOPS[token] {
    local bitop = "require('{ bitlib }').{ BITLIB_METHODS[token] }("
    return { line, bitop, lhs, line, ',', rhs, line, ')' }
  } elseif token == '!=' {
    return { lhs, line, '~=', rhs }
  } elseif token == '||' {
    return { lhs, line, 'or', rhs }
  } elseif token == '&&' {
    return { lhs, line, 'and', rhs }
  } elseif token == '//' {
    return (lua_target == '5.3' || lua_target == '5.3+' || lua_target == '5.4' || lua_target == '5.4+')
      && { lhs, line, token, rhs }
      || { line, 'math.floor(', lhs, line, '/', rhs, line, ')' }
  } else {
    return { lhs, line, token, rhs }
  }
}

-- -----------------------------------------------------------------------------
-- Macros
-- -----------------------------------------------------------------------------

local function list(callback, break_token) {
  local list = {}

  repeat {
    table.insert(list, callback() || nil)
  } until !branch(',') || (break_token && current_token.value == break_token)

  return list
}

local function surround(open_char, close_char, callback) {
  expect(open_char)
  local result = callback()
  expect(close_char)
  return result
}

local function surround_list(open_char, close_char, callback, allow_empty) {
  return surround(open_char, close_char, () -> {
    if current_token.value != close_char || !allow_empty {
      return list(callback, close_char)
    }
  })
}

-- -----------------------------------------------------------------------------
-- Variables
-- -----------------------------------------------------------------------------

local function name(no_transform) {
  ensure(current_token.value != nil, 'unexpected eof')
  ensure(
    current_token.value:match('^[_a-zA-Z][_a-zA-Z0-9]*$'),
    "unexpected token '{ current_token.value }'",
  )

  if KEYWORDS[current_token.value] {
    throw("unexpected keyword '{ current_token.value }'")
  }

  if TERMINALS[current_token.value] {
    throw("unexpected builtin '{ current_token.value }'")
  }

  if LUA_KEYWORDS[current_token.value] && !no_transform {
    return "__ERDE_SUBSTITUTE_{ consume() }__"
  }

  return consume()
}

local function destructure(scope) {
  local names = {}
  local compile_lines = {}
  local compile_name = new_tmp_name()
  local assignment_prefix = scope == 'global' && '_G.' || ''

  if current_token.value == '[' {
    local array_index = 0
    surround_list('[', ']', () -> {
      local name_line, name = current_token.line, name()
      local assignment_name = assignment_prefix .. name
      array_index += 1

      table.insert(names, name)

      table.insert(compile_lines, name_line)
      table.insert(compile_lines, "{ assignment_name } = { compile_name }[{ array_index }]")

      if branch('=') {
        table.insert(compile_lines, "if { assignment_name } == nil then { assignment_name } = ")
        table.insert(compile_lines, expression())
        table.insert(compile_lines, 'end')
      }
    })
  } else {
    surround_list('{', '}', () -> {
      -- Save `raw_key` in case `name()` transforms the word (Lua keywords)
      local key_line, raw_key, key = current_token.line, current_token.value, name()
      local name = branch(':') && name() || key
      local assignment_name = assignment_prefix .. name

      table.insert(names, name)

      table.insert(compile_lines, key_line)
      table.insert(compile_lines, "{ assignment_name } = { compile_name }['{ raw_key }']")

      if branch('=') {
        table.insert(compile_lines, "if { assignment_name } == nil then { assignment_name } = ")
        table.insert(compile_lines, expression())
        table.insert(compile_lines, 'end')
      }
    })
  }

  return {
    names = names,
    compile_name = compile_name,
    compile_lines = compile_lines,
  }
}

local function variable() {
  if current_token.value == '{' || current_token.value == '[' {
    return destructure()
  } else {
    return name()
  }
}

-- -----------------------------------------------------------------------------
-- Strings
-- -----------------------------------------------------------------------------

local function interpolation_string(start_quote, end_quote) {
  local compile_lines = {}
  local content_line, content = current_token.line, consume()
  local is_block_string = start_quote:sub(1, 1) == '['

  if current_token.value == end_quote {
    -- Handle empty string case exceptionally so we can make assumptions at the
    -- end to simplify excluding empty string concatenations.
    table.insert(compile_lines, content .. consume())
    return compile_lines
  }

  repeat {
    if current_token.value == '{' {
      if content != start_quote { -- only if nonempty
        table.insert(compile_lines, content_line)
        table.insert(compile_lines, content .. end_quote)
      }

      table.insert(compile_lines, { 'tostring(', surround('{', '}', expression), ')' })
      content_line, content = current_token.line, start_quote

      if is_block_string && current_token.value:sub(1, 1) == '\n' {
        -- Lua ignores the first character in block strings when it is a
        -- newline! We need to make sure we preserve any newline following
        -- an interpolation by inserting a second newline in the compiled code.
        -- @see http://www.lua.org/pil/2.4.html
        content ..= '\n' .. consume()
      }
    } else {
      content ..= consume()
    }
  } until current_token.value == end_quote

  if content != start_quote { -- only if nonempty
    table.insert(compile_lines, content_line)
    table.insert(compile_lines, content .. end_quote)
  }

  consume() -- end_quote
  return weave(compile_lines, '..')
}

local function single_quote_string() {
  return { current_token.line, "'" .. consume() .. "'" }
}

local function double_quote_string() {
  return interpolation_string('"', '"')
}

local function block_string() {
  return interpolation_string(current_token.value, current_token.value:gsub('%[', ']'))
}

-- -----------------------------------------------------------------------------
-- Tables
-- -----------------------------------------------------------------------------

local function table_constructor() {
  local compile_lines = {}

  surround_list('{', '}', () -> {
    if current_token.value == '[' {
      table.insert(compile_lines, '[')
      table.insert(compile_lines, surround('[', ']', expression))
      table.insert(compile_lines, ']')
      table.insert(compile_lines, expect('='))
    } elseif look_ahead(1) == '=' {
      local key = name(true)
      if LUA_KEYWORDS[key] {
        table.insert(compile_lines, "['{ key }']" .. consume())
      } else {
        table.insert(compile_lines, key .. consume())
      }
    }

    table.insert(compile_lines, expression())
    table.insert(compile_lines, ',')
  }, true)

  return { '{', compile_lines, '}' }
}

-- -----------------------------------------------------------------------------
-- Returns
-- -----------------------------------------------------------------------------

local function return_list(require_list_parens) {
  local compile_lines = {}

  if current_token.value != '(' {
    table.insert(compile_lines, require_list_parens && expression() || weave(list(expression)))
  } else {
    local look_ahead_limit_token, look_ahead_limit_token_index = look_past_surround()

    if look_ahead_limit_token == '->' || look_ahead_limit_token == '=>' {
      table.insert(compile_lines, expression())
    } else {
      local is_list = false

      for look_ahead_token_index = current_token_index + 1, look_ahead_limit_token_index - 1 {
        local look_ahead_token = tokens[look_ahead_token_index].value

        if SURROUND_ENDS[look_ahead_token] {
          look_ahead_token, look_ahead_token_index = look_past_surround(look_ahead_token_index)
        }

        if look_ahead_token == ',' {
          is_list = true
          break
        }
      }

      table.insert(compile_lines, is_list && weave(surround_list('(', ')', expression)) || expression())
    }
  }

  return compile_lines
}

local function return_statement() {
  if is_module_return_block {
    module_return_line = current_token.line
  }

  local compile_lines = { current_token.line, consume() }

  if block_depth == 1 {
    if current_token.value {
      table.insert(compile_lines, return_list())
    }

    if current_token.value {
      throw(("expected '<eof>', got '%s'"):format(current_token.value))
    }
  } else {
    if current_token.value != '}' {
      table.insert(compile_lines, return_list())
    }

    if current_token.value != '}' {
      throw(("expected '}', got '%s'"):format(current_token.value))
    }
  }

  return compile_lines
}

-- -----------------------------------------------------------------------------
-- Functions
-- -----------------------------------------------------------------------------

local function parameters() {
  local compile_lines = {}
  local names = {}
  local has_varargs = false

  surround_list('(', ')', () -> {
    if branch('...') {
      has_varargs = true
      table.insert(names, '...')

      if current_token.value != ')' {
        table.insert(compile_lines, "local { name() } = \{ ... }")
      }

      branch(',')
      expect(')', true)
    } else {
      local var = variable()
      local name = type(var) == 'string' && var || var.compile_name
      table.insert(names, name)

      if branch('=') {
        table.insert(compile_lines, "if { name } == nil then { name } = ")
        table.insert(compile_lines, expression())
        table.insert(compile_lines, 'end')
      }

      if type(var) == 'table' {
        table.insert(compile_lines, 'local ' .. table.concat(var.names, ','))
        table.insert(compile_lines, var.compile_lines)
      }
    }
  }, true)

  return { names = names, compile_lines = compile_lines, has_varargs = has_varargs }
}

local function function_block() {
  local old_is_module_return_block = is_module_return_block
  local old_break_name = break_name

  is_module_return_block = false
  break_name = nil

  local compile_lines = block()

  is_module_return_block = old_is_module_return_block
  break_name = old_break_name

  return compile_lines
}

local function arrow_function_expression() {
  local compile_lines = {}
  local param_names = {}
  local old_is_varargs_block = is_varargs_block

  if current_token.value == '(' {
    local params = parameters()
    is_varargs_block = params.has_varargs
    param_names = params.names
    table.insert(compile_lines, params.compile_lines)
  } else {
    local var = variable()
    is_varargs_block = false

    if type(var) == 'string' {
      table.insert(param_names, var)
    } else {
      table.insert(param_names, var.compile_name)
      table.insert(compile_lines, 'local ' .. table.concat(var.names, ','))
      table.insert(compile_lines, var.compile_lines)
    }
  }

  if current_token.value == '->' {
    consume()
  } elseif current_token.value == '=>' {
    table.insert(param_names, 1, 'self')
    consume()
  } elseif current_token.value == nil {
    throw("unexpected eof (expected '->' or '=>')", tokens[current_token_index - 1].line)
  } else {
    throw("unexpected token '{ current_token.value }' (expected '->' or '=>')")
  }

  table.insert(compile_lines, 1, "function({ table.concat(param_names, ',') })")

  if current_token.value == '{' {
    table.insert(compile_lines, surround('{', '}', function_block))
  } else {
    table.insert(compile_lines, { 'return', return_list(true) })
  }

  is_varargs_block = old_is_varargs_block
  table.insert(compile_lines, 'end')
  return compile_lines
}

local function function_statement() {
  local compile_lines = {}
  local scope_line, scope = current_token.line, nil

  if current_token.value == 'local' || current_token.value == 'module' {
    scope = consume()
    table.insert(compile_lines, 'local')
    table.insert(compile_lines, consume()) -- 'function'
  } elseif current_token.value == 'global' {
    scope = consume()
    table.insert(compile_lines, consume()) -- 'function'
  } elseif current_token.value == 'function' {
    table.insert(compile_lines, consume())
  } else {
    throw("unexpected token '{ current_token.value }' (expected scope)")
  }

  if scope == 'module' {
    if block_depth > 1 {
      throw('module declarations must appear at the top level', scope_line)
    }

    has_module_declarations = true
  }

  local signature = name()
  local is_table_value = current_token.value == '.'

  if scope == 'global' {
    signature = '_G.' .. signature
    is_table_value = true
  }

  while branch('.') {
    signature ..= '.' .. name()
  }

  if branch(':') {
    is_table_value = true
    signature ..= ':' .. name()
  }

  if is_table_value && (scope == 'local' || scope == 'module') {
    -- Lua does not allow scope for table functions (ex. `local function a.b()`)
    throw('cannot use scopes for table values', scope_line)
  }

  table.insert(compile_lines, signature)

  local params = parameters()
  table.insert(compile_lines, '(' .. table.concat(params.names, ',') .. ')')
  table.insert(compile_lines, params.compile_lines)

  local old_is_varargs_block = is_varargs_block
  is_varargs_block = params.has_varargs
  table.insert(compile_lines, surround('{', '}', function_block))
  is_varargs_block = old_is_varargs_block

  table.insert(compile_lines, 'end')

  if scope == 'module' {
    table.insert(compile_lines, "_MODULE.{ signature } = { signature }")
  }

  return compile_lines
}

-- -----------------------------------------------------------------------------
-- Index Chain
-- -----------------------------------------------------------------------------

local function index_chain(base_compile_lines, has_trivial_base, require_chain) {
  local chain = {}
  local is_function_call = false
  local has_trivial_chain = false

  -- Variables for when we must compile to a Lua block.
  --
  -- There are cases where we cannot keep the compiled code as an expression and
  -- must compile to a block (such as a `do` block or an IIFE). One such case is
  -- when compiling a method index with a nontrivial base when the method name
  -- is a Lua keyword, but not an Erde keyword.
  local needs_block_compile = false
  local block_compile_name = new_tmp_name()
  local block_compile_lines = { "local { block_compile_name }" }

  while true {
    if current_token.value == '[' {
      has_trivial_chain = false
      table.insert(chain, { current_token.line, '[', surround('[', ']', expression), ']' })
    } elseif current_token.value == '.' {
      has_trivial_chain = false

      local field_line = current_token.line
      consume()
      local field_name = name(true)

      if LUA_KEYWORDS[field_name] {
        table.insert(chain, { field_line, "['{ field_name }']" })
      } else {
        table.insert(chain, { field_line, '.' .. field_name })
      }
    } elseif branch(':') {
      has_trivial_chain = false
      is_function_call = true

      local link = { current_token.line }
      local method_name = name(true)
      expect('(', true)

      if !LUA_KEYWORDS[method_name] {
        table.insert(link, ':' .. method_name)
      } else {
        local arg_compile_lines = surround_list('(', ')', expression, true)

        if has_trivial_base && has_trivial_chain {
          table.insert(link, '["' .. method_name .. '"](')
          table.insert(link, "['{ method_name }'](")
          table.insert(link, base_compile_lines)
        } else {
          needs_block_compile = true
          link.needs_intermediate = true
          table.insert(link, "['{ method_name }']({ block_compile_name }")
        }

        if arg_compile_lines {
          table.insert(link, ',')
          table.insert(link, weave(arg_compile_lines))
        }

        table.insert(link, ')')
      }

      table.insert(chain, link)
    } elseif current_token.value == '(' && current_token.line == tokens[current_token_index - 1].line {
      -- Use newlines to infer whether the parentheses belong to a function call
      -- or the next statement.
      has_trivial_chain = false
      is_function_call = true

      local chain_len = #chain
      local preceding_compile_lines, preceding_compile_lines_len

      if chain_len > 0 {
        preceding_compile_lines = chain[chain_len]
        preceding_compile_lines_len = #preceding_compile_lines
      } else {
        preceding_compile_lines = base_compile_lines
        preceding_compile_lines_len = #base_compile_lines

        while type(preceding_compile_lines[preceding_compile_lines_len]) == 'table' {
          preceding_compile_lines = preceding_compile_lines[preceding_compile_lines_len]
          preceding_compile_lines_len = #preceding_compile_lines
        }
      }

      local arg_compile_lines = surround_list('(', ')', expression, true)

      -- Include function call parens on same line as function name to prevent
      -- parsing errors in Lua5.1
      --    `ambiguous syntax (function call x new statement) near '('`
      if !arg_compile_lines {
        preceding_compile_lines[preceding_compile_lines_len] =
          preceding_compile_lines[preceding_compile_lines_len] .. '()'
      } else {
        preceding_compile_lines[preceding_compile_lines_len] =
          preceding_compile_lines[preceding_compile_lines_len] .. '('
        table.insert(chain, { weave(arg_compile_lines), ')' })
      }
    } else {
      break
    }
  }

  if require_chain && has_trivial_chain {
    if !current_token.value {
      throw('unexpected eof')
    } else {
      throw("expected index chain, found '{ current_token.value }'")
    }
  }

  for _, link in ipairs(chain) {
    if link.needs_intermediate {
      table.insert(block_compile_lines, block_compile_name .. '=')
      table.insert(block_compile_lines, base_compile_lines)
      base_compile_lines = { block_compile_name }
    }

    table.insert(base_compile_lines, link)
  }

  return {
    base_compile_lines = base_compile_lines,
    is_function_call = is_function_call,
    needs_block_compile = needs_block_compile,
    block_compile_name  = block_compile_name,
    block_compile_lines = block_compile_lines,
  }
}

local function index_chain_expression(...) {
  local index_chain = index_chain(...)

  if !index_chain.needs_block_compile {
    return index_chain.base_compile_lines
  } else {
    return {
      '(function()',
      index_chain.block_compile_lines,
      'return',
      index_chain.base_compile_lines,
      'end)()',
    }
  }
}

-- -----------------------------------------------------------------------------
-- Expressions
-- -----------------------------------------------------------------------------

local function terminal_expression() {
  ensure(current_token.value != nil, 'unexpected eof')
  ensure(current_token.value != '...' || is_varargs_block, "cannot use '...' outside a vararg function")

  if TERMINALS[current_token.value] {
    return { current_token.line, consume() }
  }

  if DIGIT[current_token.value:sub(1, 1)] {
    return { current_token.line, consume() }
  } elseif tokens[current_token_index].type == TOKEN_TYPES.SINGLE_QUOTE_STRING {
    return index_chain_expression({ '(', single_quote_string(), ')' }, true)
  } elseif current_token.value == '"' {
    -- TODO: check for interpolation to determine index_chain.has_trivial_base?
    return index_chain_expression({ '(', double_quote_string(), ')' }, false)
  } elseif current_token.value:match('^%[[[=]') {
    -- TODO: check for interpolation to determine index_chain.has_trivial_base?
    return index_chain_expression({ '(', block_string(), ')' }, false)
  }

  local next_token = look_ahead(1)
  local is_arrow_function = next_token == '->' || next_token == '=>'

  -- First do a quick check for is_arrow_function (in case of implicit params),
  -- otherwise if surround_end is truthy (possible params), need to check the
  -- next token after. This is _much_ faster than backtracking.
  if !is_arrow_function && SURROUND_ENDS[current_token.value] {
    local past_surround_token = look_past_surround()
    is_arrow_function = past_surround_token == '->' || past_surround_token == '=>'
  }

  if is_arrow_function {
    return arrow_function_expression()
  } elseif current_token.value == '{' {
    return table_constructor()
  } elseif current_token.value == '(' {
    return index_chain_expression({ '(', surround('(', ')', expression), ')' }, false)
  } else {
    return index_chain_expression({ current_token.line, name() }, true)
  }
}

local function unop_expression() {
  local compile_lines  = {}
  local unop_line, unop = current_token.line, UNOPS[consume()]
  local operand_line, operand = current_token.line, expression(unop.prec + 1)

  if unop.token == '~' {
    if bitlib {
      local bitop = "require('{ bitlib }').bnot("
      return { unop_line, bitop, operand_line, operand, unop_line, ')' }
    } elseif lua_target == '5.1+' || lua_target == '5.2+' {
      throw('must specify bitlib for compiling bit operations when targeting 5.1+ or 5.2+', unop_line)
    } else {
      return { unop_line, unop.token, operand_line, operand }
    }
  } elseif unop.token == '!' {
    return { unop_line, 'not', operand_line, operand }
  } else {
    return { unop_line, unop.token, operand_line, operand }
  }
}

function expression(min_prec = 1) {
  local compile_lines = UNOPS[current_token.value] && unop_expression() || terminal_expression()
  local binop = BINOPS[current_token.value]

  while binop && binop.prec >= min_prec {
    local binop_line = current_token.line
    consume()

    local rhs_min_prec = binop.prec
    if binop.assoc == LEFT_ASSOCIATIVE {
      rhs_min_prec += 1
    }

    if BITOPS[binop.token] && (lua_target == '5.1+' || lua_target == '5.2+') && !bitlib {
      throw('must specify bitlib for compiling bit operations when targeting 5.1+ or 5.2+', binop_line)
    }

    compile_lines = compile_binop(binop.token, binop_line, compile_lines, expression(rhs_min_prec))
    binop = BINOPS[current_token.value]
  }

  return compile_lines
}

-- -----------------------------------------------------------------------------
-- Blocks
-- -----------------------------------------------------------------------------

function block() {
  local compile_lines = {}

  block_depth += 1

  while current_token.value != '}' {
    table.insert(compile_lines, statement())
  }

  block_depth -= 1

  return compile_lines
}

local function do_statement() {
  return {
    consume(), -- 'do'
    surround('{', '}', block),
    'end',
  }
}

-- -----------------------------------------------------------------------------
-- Loops
-- -----------------------------------------------------------------------------

local function break_statement() {
  if break_name == nil {
    throw("cannot use 'break' outside of loop")
  }

  return consume()
}

local function continue_statement() {
  if break_name == nil {
    throw("cannot use 'continue' outside of loop")
  }

  has_continue = true
  consume()

  if lua_target == '5.1' || lua_target == '5.1+' {
    return "{ break_name } = false break"
  } else {
    return "goto { break_name }"
  }
}

local function loop_block() {
  local old_break_name = break_name
  local old_has_continue = has_continue

  break_name = new_tmp_name()
  has_continue = false

  local compile_lines = block()

  if has_continue {
    if lua_target == '5.1' || lua_target == '5.1+' {
      table.insert(compile_lines, 1, "local { break_name } = true repeat")
      table.insert(compile_lines, "{ break_name } = false until true if { break_name } then break end")
    } else {
      table.insert(compile_lines, "::{ break_name }::")
    }
  }

  break_name = old_break_name
  has_continue = old_has_continue

  return compile_lines
}

local function for_loop_statement() {
  local compile_lines = {}
  local pre_body_compile_lines = {}

  table.insert(compile_lines, consume()) -- 'for'

  if look_ahead(1) == '=' {
    table.insert(compile_lines, current_token.line)
    table.insert(compile_lines, name() .. consume())

    local expr_list_line = current_token.line
    local expr_list = list(expression)
    local expr_list_len = #expr_list

    if expr_list_len != 2 && expr_list_len != 3 {
      throw("invalid numeric for, expected 2-3 expressions, got { expr_list_len }", expr_list_line)
    }

    table.insert(compile_lines, weave(expr_list))
  } else {
    local names = {}

    for _, var in ipairs(list(variable)) {
      if type(var) == 'string' {
        table.insert(names, var)
      } else {
        table.insert(names, var.compile_name)
        table.insert(pre_body_compile_lines, 'local ' .. table.concat(var.names, ','))
        table.insert(pre_body_compile_lines, var.compile_lines)
      }
    }

    table.insert(compile_lines, weave(names))
    table.insert(compile_lines, expect('in'))
    table.insert(compile_lines, weave(list(expression)))
  }

  table.insert(compile_lines, 'do')
  table.insert(compile_lines, pre_body_compile_lines)
  table.insert(compile_lines, surround('{', '}', loop_block))
  table.insert(compile_lines, 'end')

  return compile_lines
}

local function repeat_until_statement() {
  return {
    consume(), -- 'repeat'
    surround('{', '}', loop_block),
    expect('until'),
    expression(),
  }
}

local function while_loop_statement() {
  return {
    consume(), -- 'while'
    expression(),
    'do',
    surround('{', '}', loop_block),
    'end',
  }
}

-- -----------------------------------------------------------------------------
-- Jumps
-- -----------------------------------------------------------------------------

local function goto_jump_statement() {
  if lua_target == '5.1' || lua_target == '5.1+' {
    throw("'goto' statements only compatibly with lua targets 5.2+, jit")
  }

  return {
    consume(), -- 'goto'
    current_token.line,
    name(),
  }
}

local function goto_label_statement() {
  if lua_target == '5.1' || lua_target == '5.1+' {
    throw("'goto' statements only compatibly with lua targets 5.2+, jit")
  }

  return consume() .. name() .. expect('::')
}

local function if_else_statement() {
  local compile_lines = {}

  table.insert(compile_lines, consume()) -- 'if'
  table.insert(compile_lines, expression())
  table.insert(compile_lines, 'then')
  table.insert(compile_lines, surround('{', '}', block))

  while current_token.value == 'elseif' {
    table.insert(compile_lines, consume())
    table.insert(compile_lines, expression())
    table.insert(compile_lines, 'then')
    table.insert(compile_lines, surround('{', '}', block))
  }

  if current_token.value == 'else' {
    table.insert(compile_lines, consume())
    table.insert(compile_lines, surround('{', '}', block))
  }

  table.insert(compile_lines, 'end')

  return compile_lines
}

-- -----------------------------------------------------------------------------
-- Statements
-- -----------------------------------------------------------------------------

-- TODO: refactor?
local function assignment_statement(first_id) {
  local compile_lines = {}
  local index_chains = { first_id }
  local base_compile_lines = { first_id.base_compile_lines }
  local needs_block_compile = first_id.needs_block_compile

  while branch(',') {
    local index_chain_line = current_token.line
    local index_chain = current_token.value == '('
      && index_chain({ '(', surround('(', ')', expression), ')' }, false, true)
      || index_chain({ name() }, true)

    if index_chain.is_function_call {
      throw('cannot assign value to function call', index_chain_line)
    }

    needs_block_compile ||= index_chain.needs_block_compile
    table.insert(index_chains, index_chain)
    table.insert(base_compile_lines, index_chain.base_compile_lines)
  }

  local op_line, op_token = current_token.line, BINOP_ASSIGNMENT_TOKENS[current_token.value] && consume()
  if BITOPS[op_token] && (lua_target == '5.1+' || lua_target == '5.2+') && !bitlib {
    throw('must specify bitlib for compiling bit operations when targeting 5.1+ or 5.2+', op_line)
  }

  expect('=')
  local expr_list = list(expression)

  -- Optimize most common use cases
  if !needs_block_compile && !op_token {
    table.insert(compile_lines, weave(base_compile_lines))
    table.insert(compile_lines, '=')
    table.insert(compile_lines, weave(expr_list))
  } elseif !needs_block_compile && #index_chains == 1 {
    table.insert(compile_lines, first_id.base_compile_lines)
    table.insert(compile_lines, op_line)
    table.insert(compile_lines, '=')
    table.insert(compile_lines, compile_binop(op_token, op_line, first_id.base_compile_lines, expr_list[1]))
  } else {
    local assignment_names = {}
    local assignment_compile_lines = {}

    for _, id in ipairs(index_chains) {
      local assignment_name = new_tmp_name()
      table.insert(assignment_names, assignment_name)

      if id.needs_block_compile {
        table.insert(assignment_compile_lines, id.block_compile_lines)
      }

      table.insert(assignment_compile_lines, id.base_compile_lines)
      table.insert(assignment_compile_lines, '=')
      table.insert(assignment_compile_lines, op_token
        && compile_binop(op_token, op_line, id.base_compile_lines, assignment_name)
        || assignment_name
      )
    }

    table.insert(compile_lines, 'do')
    table.insert(compile_lines, 'local')
    table.insert(compile_lines, table.concat(assignment_names, ','))
    table.insert(compile_lines, '=')
    table.insert(compile_lines, weave(expr_list))
    table.insert(compile_lines, assignment_compile_lines)
    table.insert(compile_lines, 'end')
  }

  return compile_lines
}

-- TODO: refactor?
local function declaration_statement() {
  local scope = consume()

  local compile_lines = {}
  local destructure_compile_lines = {}

  local declaration_names = {}
  local destructure_compile_names = {}
  local assignment_names = {}

  if scope == 'module' {
    if block_depth > 1 {
      throw('module declarations must appear at the top level', tokens[current_token_index - 1].line)
    }

    has_module_declarations = true
  }

  for _, var in ipairs(list(() -> variable(scope))) {
    if type(var) == 'string' {
      table.insert(declaration_names, var)
      table.insert(assignment_names, (scope == 'global' && '_G.' || '') .. var)
    } else {
      table.insert(assignment_names, var.compile_name)
      table.insert(destructure_compile_names, var.compile_name)
      table.insert(destructure_compile_lines, var.compile_lines)

      for _, name in ipairs(var.names) {
        table.insert(declaration_names, name)
      }
    }
  }

  if scope != 'global' {
    table.insert(compile_lines, 'local ' .. table.concat(declaration_names, ','))
  }

  if branch('=') {
    if #destructure_compile_names > 0 {
      table.insert(compile_lines, 'do')
      table.insert(compile_lines, 'local ' .. table.concat(destructure_compile_names, ','))
      table.insert(compile_lines, table.concat(assignment_names, ',') .. '=')
      table.insert(compile_lines, weave(list(expression)))
      table.insert(compile_lines, destructure_compile_lines)
      table.insert(compile_lines, 'end')
    } elseif scope == 'global' {
      table.insert(compile_lines, table.concat(assignment_names, ',') .. '=')
      table.insert(compile_lines, weave(list(expression)))
    } else {
      table.insert(compile_lines, '=')
      table.insert(compile_lines, weave(list(expression)))
    }

    if scope == 'module' {
      local module_names = {}

      for _, declaration_name in ipairs(declaration_names) {
        table.insert(module_names, '_MODULE.' .. declaration_name)
      }

      table.insert(compile_lines, ('%s = %s'):format(
        table.concat(module_names, ','),
        table.concat(declaration_names, ',')
      ))
    }
  }

  return compile_lines
}

-- -----------------------------------------------------------------------------
-- Statement
-- -----------------------------------------------------------------------------

function statement() {
  local compile_lines = {}

  if current_token.value == 'break' {
    table.insert(compile_lines, break_statement())
  } elseif current_token.value == 'continue' {
    table.insert(compile_lines, continue_statement())
  } elseif current_token.value == 'goto' {
    table.insert(compile_lines, goto_jump_statement())
  } elseif current_token.value == '::' {
    table.insert(compile_lines, goto_label_statement())
  } elseif current_token.value == 'do' {
    table.insert(compile_lines, do_statement())
  } elseif current_token.value == 'if' {
    table.insert(compile_lines, if_else_statement())
  } elseif current_token.value == 'for' {
    table.insert(compile_lines, for_loop_statement())
  } elseif current_token.value == 'while' {
    table.insert(compile_lines, while_loop_statement())
  } elseif current_token.value == 'repeat' {
    table.insert(compile_lines, repeat_until_statement())
  } elseif current_token.value == 'return' {
    table.insert(compile_lines, return_statement())
  } elseif current_token.value == 'function' {
    table.insert(compile_lines, function_statement())
  } elseif current_token.value == 'local' || current_token.value == 'global' || current_token.value == 'module' {
    if look_ahead(1) == 'function' {
      table.insert(compile_lines, function_statement())
    } else {
      table.insert(compile_lines, declaration_statement())
    }
  } else {
    -- TODO: refactor?
    local index_chain = current_token.value == '('
      && index_chain({ current_token.line, '(', surround('(', ')', expression), ')' }, false, true)
      || index_chain({ current_token.line, name() }, true)

    if !index_chain.is_function_call {
      table.insert(compile_lines, assignment_statement(index_chain))
    } elseif !index_chain.needs_block_compile {
      table.insert(compile_lines, index_chain.base_compile_lines)
    } else {
      table.insert(compile_lines, {
        '(function()',
        index_chain.block_compile_lines,
        'return',
        index_chain.base_compile_lines,
        'end)()',
      })
    }
  }

  if current_token.value == ';' {
    table.insert(compile_lines, consume())
  } elseif current_token.value == '(' {
    -- Add semi-colon to prevent ambiguous Lua code
    table.insert(compile_lines, ';')
  }

  return compile_lines
}

-- -----------------------------------------------------------------------------
-- Module
-- -----------------------------------------------------------------------------

local function module_block(options) {
  local compile_lines = {}

  if current_token.type == TOKEN_TYPES.SHEBANG {
    table.insert(compile_lines, consume())
  }

  while current_token.type != TOKEN_TYPES.EOF {
    table.insert(compile_lines, statement())
  }

  if has_module_declarations {
    if module_return_line != nil {
      throw("cannot use 'return' w/ 'module' declarations", module_return_line)
    }

    table.insert(compile_lines, 1, 'local _MODULE = {}')
    table.insert(compile_lines, 'return _MODULE')
  }

  return compile_lines
}

-- -----------------------------------------------------------------------------
-- Main
-- -----------------------------------------------------------------------------

return (source, options = {}) -> {
  tokens = tokenize(source, options.alias)
  current_token_index = 1
  current_token = tokens[current_token_index]
  block_depth = 1
  tmp_name_counter = 1
  break_name = nil
  has_continue = false
  has_module_declarations = false
  is_module_return_block = true
  module_return_line = nil
  is_varargs_block = true
  alias = options.alias || get_source_alias(source)
  lua_target = options.lua_target || config.lua_target
  bitlib = options.bitlib || config.bitlib
    || (lua_target == '5.1' && 'bit') -- Mike Pall's LuaBitOp
    || (lua_target == 'jit' && 'bit') -- Mike Pall's LuaBitOp
    || (lua_target == '5.2' && 'bit32') -- Lua 5.2's builtin bit32 library

  -- Keep track of the last known source line and assign it to compiled lines
  -- with no source. We do this because Lua may give an error at the line of the
  -- _next_ token in certain cases. For example, the following will give an
  -- error at line 3, instead of line 2 where the nil index actually occurs:
  --   local x = nil
  --   print(x.a
  --   )
  local source_line = current_token.line
  local source_map = {}

  local collapsed_compile_lines = {}
  local collapsed_compile_line_counter = 0

  -- TODO: refactor (move outside?)
  local function collect_compile_lines(lines) {
    for _, line in ipairs(lines) {
      if type(line) == 'number' {
        source_line = line
      } elseif type(line) == 'string' {
        table.insert(collapsed_compile_lines, line)
        collapsed_compile_line_counter += 1
        source_map[collapsed_compile_line_counter] = source_line
      } else {
        collect_compile_lines(line)
      }
    }
  }

  local compile_lines = module_block(options)
  collect_compile_lines(compile_lines)

  table.insert(collapsed_compile_lines, '-- Compiled with Erde ' .. VERSION)
  table.insert(collapsed_compile_lines, COMPILED_FOOTER_COMMENT)

  return table.concat(collapsed_compile_lines, '\n'), source_map
}
