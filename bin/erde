#!/usr/bin/env luajit

local argparse = require('argparse')
local lfs = require('lfs')
local erde = require('erde')
local C = require('erde.constants')

local CWD = lfs.currentdir()

-- -----------------------------------------------------------------------------
-- Helpers
-- -----------------------------------------------------------------------------

local function split(str, separator)
  separator = separator or '%s'
  local result = {}

  for match in string.gmatch(str, '([^'..separator..']+)') do
    table.insert(result, match)
  end

  return result
end

local function fileExists(filePath)
  local file = io.open(filePath, 'r')

  if file == nil then
    return false
  end

  file:close()
  return true
end

-- Join multiple file paths together using the platform specific path separator
-- and remove any duplicate separators.
local function pathJoin(...)
  return table.concat({ ... }, C.PATH_SEPARATOR)
    :gsub(C.PATH_SEPARATOR .. '+', C.PATH_SEPARATOR)
end

-- Check whether a file has been generated from `erde` by checking if one of 
-- the file's first two lines match `C.COMPILED_HEADER_COMMENT`.
--
-- Note we have to check the first _two_ lines in case the first is a shebang.
local function isCompiledFile(filePath)
  local file = io.open(filePath, 'r')

  if file == nil then
    return false
  end

  local head1, head2 = file:read('*l'), file:read('*l')
  file:close()

  return (head1 and head1:find(C.COMPILED_HEADER_COMMENT)) 
    or (head2 and head2:find(C.COMPILED_HEADER_COMMENT))
end

local function traverseDir(root, callback)
  for fileName in lfs.dir(root) do
    if fileName ~= '.' and fileName ~= '..' then
      local filePath = pathJoin(root, fileName)
      local attributes = lfs.attributes(filePath)

      if attributes ~= nil then
        if attributes.mode == 'directory' then
          traverseDir(filePath, callback)
        elseif attributes.mode == 'file' then
          callback(filePath)
        end
      end
    end
  end
end

local function traverseErdeFiles(root, callback)
  traverseDir(root, function(filePath)
    if filePath:match('%.erde$') then
      callback(filePath)
    end
  end)
end

local function traverseLuaFiles(root, callback)
  traverseDir(root, function(filePath)
    if filePath:match('%.lua$') then
      callback(filePath)
    end
  end)
end

-- -----------------------------------------------------------------------------
-- Compile
-- -----------------------------------------------------------------------------

local function compileFile(srcFilePath, outDir)
  local destFilePath = srcFilePath:gsub('%.erde$', '.lua')

  if outDir then
    destFilePath = destFilePath:gsub(CWD, outDir)
  end

  if fileExists(destFilePath) and not isCompiledFile(destFilePath) then
    error('Cannot write to ' .. destFilePath .. ': File already exists')
  end

  local srcFile = io.open(srcFilePath, 'r')
  local compiled = erde.compile(srcFile:read('*a'))
  srcFile:close()

  local destFile = io.open(destFilePath, 'w')
  destFile:write(compiled)

  print(
    srcFilePath:gsub(CWD .. C.PATH_SEPARATOR, '')
    .. ' -> '
    .. destFilePath:gsub(CWD .. C.PATH_SEPARATOR, '')
  )
end

local function compile(args)
  local files = #args.paths > 0 and args.paths or {'.'}

  for i, filePath in ipairs(files) do
    local attributes = lfs.attributes(filePath)
    if attributes.mode == 'file' then
      compileFile(filePath, outDir)
    elseif attributes.mode == 'directory' then
      traverseErdeFiles(filePath, function(compileFilePath)
        compileFile(compileFilePath, outDir)
      end)
    end
  end
end

-- -----------------------------------------------------------------------------
-- Clean
-- -----------------------------------------------------------------------------

local function cleanFile(filePath)
  if isCompiledFile(filePath) then
    os.remove(filePath)
    print('Removed ' .. filePath)
  end
end

local function clean(args)
  local files = #args.paths > 0 and args.paths or {'.'}

  for i, filePath in ipairs(files) do
    local attributes = lfs.attributes(filePath)
    if attributes.mode == 'file' then
      cleanFile(filePath)
    elseif attributes.mode == 'directory' then
      traverseLuaFiles(filePath, cleanFile)
    end
  end
end

-- -----------------------------------------------------------------------------
-- Run
-- -----------------------------------------------------------------------------

local function run(args)
  local modulePath = pathJoin(CWD, args.paths[1])
  local moduleFile = io.open(modulePath)

  if moduleFile == nil then
    return 'File does not exist: ' .. args.paths[1]
  end

  local moduleContents = moduleFile:read('*a')
  moduleFile:close()
  return erde.run(moduleContents)
end

-- -----------------------------------------------------------------------------
-- CLI
-- -----------------------------------------------------------------------------

local cli = argparse('erde')

cli._usage = 'Usage: erde [-C|-X] [PATH...]'
cli:epilog('See `erde --usage` for examples / detailed usage.')

local function option(shortFlag, longFlag, description)
  local longName = longFlag:sub(3)

  local option = cli:option({
    argname = '<'..longName..'>',
    target = longName,
    description = description,
  })

  -- Hack to customize help output. We use this to force the flags to remain
  -- on one line and deduplicate the argname.
  option._public_aliases = { shortFlag .. ', ' .. longFlag }
  option._aliases = { shortFlag, longFlag }

  return option
end

cli:flag('-v --version', 'Show version and exit.')
cli:flag('-u --usage', 'Show detailed usage and exit.')
cli:argument('paths'):args('*'):hidden(true)

cli:group('-C, --compile',
  cli:flag('-C --compile'):hidden(true),
  -- IMPORTANT: Keep these choices in sync w/ `erde.targets`!
  option('-t', '--target', 'Lua target. Must be one of:\n  JIT, 5.1, 5.1+, 5.2, 5.2+, 5.3, 5.3+, 5.4, 5.4+'),
  option('-o', '--outDir', 'Output directory for compiled files.')
)

local args = cli:parse()
print(require('inspect')(args))

if args.version then
  print('0.2-1')
elseif args.compile then
  compile(args)
elseif args.clean then
  clean(args)
elseif #args.paths == 1 then
  run(args)
else
  print('REPL not yet supported.')
end
