#!/usr/bin/env lua

local argparse = require('argparse')
local lfs = require('lfs')
local erde = require('erde')
local luaTarget = require('erde.luaTarget')
local C = require('erde.constants')

local CWD = lfs.currentdir()

-- -----------------------------------------------------------------------------
-- Helpers
-- -----------------------------------------------------------------------------

local function fileExists(filePath)
  local file = io.open(filePath, 'r')

  if file == nil then
    return false
  end

  file:close()
  return true
end

-- Join multiple file paths together using the platform specific path separator
-- and remove any duplicate separators.
local function pathJoin(...)
  return table.concat({ ... }, C.PATH_SEPARATOR)
    :gsub(C.PATH_SEPARATOR .. '+', C.PATH_SEPARATOR)
end

-- Check whether a file has been generated from `erde` by checking if one of 
-- the file's first two lines match `C.COMPILED_HEADER_COMMENT`.
--
-- Note we have to check the first _two_ lines in case the first is a shebang.
local function isCompiledFile(filePath)
  local file = io.open(filePath, 'r')

  if file == nil then
    return false
  end

  local head1, head2 = file:read('*l'), file:read('*l')
  file:close()

  return (head1 and head1:find(C.COMPILED_HEADER_COMMENT)) 
    or (head2 and head2:find(C.COMPILED_HEADER_COMMENT))
end

local function traversePaths(paths, callback)
  for i, path in ipairs(paths) do
    local attributes = lfs.attributes(path)

    if attributes ~= nil then
      if attributes.mode == 'file' then
        callback(path)
      elseif attributes.mode == 'directory' then
        local subPaths = {}

        for fileName in lfs.dir(path) do
          if fileName ~= '.' and fileName ~= '..' then
            subPaths[#subPaths + 1] = pathJoin(path, fileName)
          end
        end

        traversePaths(subPaths, callback)
      end
    end
  end
end

local function traverseErdeFiles(paths, callback)
  traversePaths(paths, function(filePath)
    if filePath:match('%.erde$') then
      callback(filePath)
    end
  end)
end

local function traverseLuaFiles(paths, callback)
  traversePaths(paths, function(filePath)
    if filePath:match('%.lua$') then
      callback(filePath)
    end
  end)
end

-- -----------------------------------------------------------------------------
-- CLI
-- -----------------------------------------------------------------------------

local cli = argparse('erde')

local function option(shortFlag, longFlag, description)
  local longName = longFlag:sub(3)

  local option = cli:option({
    argname = '<'..longName..'>',
    target = longName,
    description = description,
  })

  -- Hack to customize help output. We use this to force the flags to remain
  -- on one line and deduplicate the argname.
  option._public_aliases = { shortFlag .. ', ' .. longFlag }
  option._aliases = { shortFlag, longFlag }

  return option
end

cli._usage = 'Usage: erde [-C|-X] [PATH...]'

cli:description(
  table.concat({
    'erde is the CLI for running and compiling `*.erde` files.',
    'It expects either zero or one "main" flags to determine what to do (similar to pacman operations).',
    'No main flag is used for both the REPL and running *.erde files directly,',
    'while the -C and -X flags are used for compiling and cleaning.',
  }, ' ')
)

cli:epilog(
  table.concat({
    'Examples:',
    '   erde',
    '      Launch the REPL',
    '',
    '   erde my_script.erde my_other_script.erde',
    '      Run my_script.erde first, then my_other_script.erde. Compilation is done in memory.',
    '',
    '   erde -C',
    '      Compile all *.erde files under the current directory.',
    '',
    '   erde -C my_script.erde',
    '      Compile my_script.erde (into my_script.lua).',
    '',
    '   erde -C src',
    '      Compile all *.erde files in src.',
    '',
    '   erde -C -o dest src',
    '      Compile all *.erde files in src and place the *.lua files under dest.',
    '',
    '   erde -X',
    '      Remove all generated *.lua files under the current directory.',
    '',
    '   erde -X src',
    '      Remove all generated *.lua files in src.',
    '',
    '   erde -X my_script.lua',
    '      Remove my_script.lua if and only if it has been generated by this script.',
  }, '\n')
)

cli:flag('-v --version', 'Show version and exit.')
cli:argument('paths'):args('*'):hidden(true)

cli:flag('-X --clean'):hidden(true)
cli:flag('-C --compile'):hidden(true)

-- TODO: remove me later
cli:flag('-F --fast'):hidden(true)

cli:group('-C, --compile',
  option('-t', '--target', 'Lua target. Must be one of:\n  ' .. table.concat(C.VALID_LUA_TARGETS, ', ')),
  option('-o', '--outDir', 'Output directory for compiled files.')
)

local args = cli:parse()

-- -----------------------------------------------------------------------------
-- Actions
-- -----------------------------------------------------------------------------

local function clean(filePath)
  if isCompiledFile(filePath) then
    os.remove(filePath)
    print('Removed ' .. filePath)
  end
end

local function compile(filePath)
  local destFilePath = filePath:gsub('%.erde$', '.lua')

  if args.outDir then
    destFilePath = destFilePath:gsub(CWD, args.outDir)
  end

  if fileExists(destFilePath) and not isCompiledFile(destFilePath) then
    error('Cannot write to ' .. destFilePath .. ': File already exists')
  end

  local srcFile = io.open(filePath, 'r')
  local compiled = erde.compile(srcFile:read('*a'))
  srcFile:close()

  local destFile = io.open(destFilePath, 'w')
  destFile:write(compiled)

  print(
    filePath:gsub(CWD .. C.PATH_SEPARATOR, '')
    .. ' -> '
    .. destFilePath:gsub(CWD .. C.PATH_SEPARATOR, '')
  )
end

local function run()
  for i, path in ipairs(args.paths) do
    local modulePath = pathJoin(CWD, path)
    local moduleFile = io.open(modulePath)

    if moduleFile == nil then
      error('Unable to find file: ' .. path)
    end

    local moduleContents = moduleFile:read('*a')
    moduleFile:close()
    erde.run(moduleContents)
  end
end

-- TODO: remove me later
local function fastRun()
  for i, path in ipairs(args.paths) do
    local modulePath = pathJoin(CWD, path)
    local moduleFile = io.open(modulePath)

    if moduleFile == nil then
      error('Unable to find file: ' .. path)
    end

    local moduleContents = moduleFile:read('*a')
    moduleFile:close()

    local source = require('erde.fastCompile')(moduleContents)
    local loader, err = (loadstring or load)(source)

    if type(loader) == 'function' then
      print(source)
      loader()
    else
      error(table.concat({
        'Failed to load compiled Lua.',
        'Error: ' .. err,
        'Compiled Code: ' .. source,
      }, '\n'))
    end
  end
end

-- -----------------------------------------------------------------------------
-- Main
-- -----------------------------------------------------------------------------

if args.target then
  luaTarget.current = args.target
end

if args.version then
  print('0.2-1')
elseif args.compile then
  traverseErdeFiles(#args.paths > 0 and args.paths or { '.' }, compile)
elseif args.clean then
  traverseLuaFiles(#args.paths > 0 and args.paths or { '.' }, clean)
elseif #args.paths == 0 then
  print('REPL not yet supported.')
elseif args.fast then
  fastRun()
else
  run()
end
