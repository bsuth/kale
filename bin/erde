#!/usr/bin/env lua

local lfs = require('lfs')
local C = require('erde.constants')
local compile = require('erde.compile')
local lib = require('erde.lib')
local repl = require('erde.repl')
local utils = require('erde.utils')

local CWD = lfs.currentdir()

local HELP = ([[
Usage: erde [command] [args]

Commands:
   compile                Compile Erde files into Lua.
   clean                  Remove generated Lua files.

Options:
   -h, --help             Show this help message and exit.
   -v, --version          Show version and exit.
   -d, --debug            Expose internal stack calls in tracebacks.
   -t, --target <TARGET>  Lua target for version compatability.
                          Must be one of: %s

Compile Options:
   -o, --outDir <DIR>     Output directory for compiled files.
   -b, --bitLib <LIB>     Library to use for compiled bit operations.
   -w, --watch            Watch files and recompile on change.

Examples:
   erde
      Launch the REPL.

   erde my_script.erde
      Run my_script.erde.

   erde compile my_script.erde
      Compile my_script.erde (into my_script.lua).

   erde compile .
      Compile all *.erde files under the current directory.

   erde compile src -o dest
      Compile all *.erde files in src and place the *.lua files under dest.

   erde clean my_script.lua
      Remove my_script.lua if and only if it has been generated by `erde compile`.

   erde clean .
      Remove all generated *.lua files under the current directory.
]]):format(table.concat(C.VALID_LUA_TARGETS, ', '))

local subCommand = nil
local outDir = CWD
local watch = false
local args = {}

-- -----------------------------------------------------------------------------
-- Helpers
-- -----------------------------------------------------------------------------

local function terminate(message, status)
  print(message)
  os.exit(status or 1)
end

-- Check whether a file has been generated from `erde` by checking if the file
-- ends with `C.COMPILED_FOOTER_COMMENT`.
local function isCompiledFile(filePath)
  local file = io.open(filePath, 'r')

  if file == nil then
    return false
  end

  file:seek('end', -C.COMPILED_FOOTER_COMMENT_LEN)
  local footer = file:read(C.COMPILED_FOOTER_COMMENT_LEN)
  file:close()

  return footer == C.COMPILED_FOOTER_COMMENT
end

local function traverseFiles(paths, fileMatch, callback)
  for i, path in ipairs(paths) do
    local attributes = lfs.attributes(path)

    if attributes ~= nil then
      if attributes.mode == 'file' then
        if fileMatch == nil or path:match(fileMatch) then
          callback(path, attributes)
        end
      elseif attributes.mode == 'directory' then
        local subPaths = {}

        for fileName in lfs.dir(path) do
          if fileName ~= '.' and fileName ~= '..' then
            table.insert(subPaths, utils.joinPaths(path, fileName))
          end
        end

        traverseFiles(subPaths, fileMatch, callback)
      end
    end
  end
end

-- -----------------------------------------------------------------------------
-- Actions
-- -----------------------------------------------------------------------------

local function compileFile(srcFilePath, includeTimestamp)
  local destFilePath = srcFilePath:gsub('%.erde$', '.lua')
  if args.outDir then
    destFilePath = args.outDir .. '/' .. destFilePath
  end

  if utils.fileExists(destFilePath) and not isCompiledFile(destFilePath) then
    print(srcFilePath .. ' => ERROR')
    print('Cannot write to ' .. destFilePath .. ': File already exists')
    return false
  end

  local srcFile = io.open(srcFilePath, 'r')
  local src = srcFile:read('*a')
  srcFile:close()

  local ok, result = pcall(function()
    return compile(src)
  end)

  if not ok then
    print(srcFilePath .. ' => ERROR')

    if type(result == 'table') and result.line then
      print(('erde:%d: %s'):format(result.line, result.message))
    else
      print('erde: ' .. tostring(result))
    end

    return false
  end

  local destFile = io.open(destFilePath, 'w')
  destFile:write(result)
  destFile:close()

  if includeTimestamp then
    print(('[%s] %s => %s'):format(os.date('%X'), srcFilePath, destFilePath))
  else
    print(('%s => %s'):format(srcFilePath, destFilePath))
  end

  return true
end

local function watchFiles(paths)
  local modifications = {}
  local pollIntervalSeconds = 1

  local hasSocket, socket = pcall(function() return require('socket') end)
  local hasPosix, posix = pcall(function() return require('posix.unistd') end)
  if not hasSocket and not hasPosix then
    print(table.concat({
      'WARNING: No libraries with sleep functionality found. This will ',
      'cause high CPU usage while watching. To fix this, you can install ',
      'either LuaSocket (https://luarocks.org/modules/luasocket/luasocket) ',
      'or luaposix (https://luarocks.org/modules/gvvaughan/luaposix)\n',
    }))
  end

  while true do
    traverseFiles(paths, '%.erde$', function(filePath, attributes)
      if not modifications[filePath] or modifications[filePath] ~= attributes.modification then
        modifications[filePath] = attributes.modification
        compileFile(filePath, true)
      end
    end)

    if hasSocket then
      socket.sleep(pollIntervalSeconds)
    elseif hasPosix then
      posix.sleep(pollIntervalSeconds)
    else
      local lastTimeout = os.time()
      repeat until os.time() - lastTimeout > pollIntervalSeconds
    end
  end
end

-- IMPORTANT: THIS IS AN ERDE SOURCE LOADER AND MUST ADHERE TO THE USAGE SPEC OF
-- `__erde_internal_load_source__`!
local function runFile(filePath)
  local ok, result = pcall(function()
    local sourceCode = utils.readFile(filePath)
    local result = lib.__erde_internal_load_source__(sourceCode, filePath)
    return result
  end)

  if not ok then
    if type(result) == 'table' and result.__is_erde_error__ then
      terminate('erde: ' .. result.stacktrace or result.message)
    else
      terminate(table.concat({
        'Internal error: ' .. tostring(result),
        'Please report this at: https://github.com/erde-lang/erde/issues',
      }, '\n'))
    end
  end
end

-- -----------------------------------------------------------------------------
-- CLI Parsing
-- -----------------------------------------------------------------------------

local cliInputs = arg
local cliInputsIndex = 1

local function cliOption(label)
  cliInputsIndex = cliInputsIndex + 1
  local optionValue = cliInputs[cliInputsIndex]

  if not optionValue then
    terminate('Missing argument for ' .. label)
  end

  return optionValue
end

if cliInputs[1] == 'compile' or cliInputs[1] == 'clean' then
  subCommand = cliInputs[1]
  cliInputsIndex = cliInputsIndex + 1
end

while cliInputsIndex <= #cliInputs do
  local cliInput = cliInputs[cliInputsIndex]

  if cliInput == '-h' or cliInput == '--help' then
    terminate(HELP, 0)
  elseif cliInput == '-v' or cliInput == '--version' then
    terminate(C.VERSION, 0)
  elseif cliInput == '-d' or cliInput == '--debug' then
    C.DEBUG = true
  elseif cliInput == '-w' or cliInput == '--watch' then
    watch = true
  elseif cliInput == '-t' or cliInput == '--target' then
    C.LUA_TARGET = cliOption(cliInput)
    if not C.VALID_LUA_TARGETS[C.LUA_TARGET] then
      terminate(table.concat({
        'Invalid Lua target: ' .. C.LUA_TARGET,
        'Must be one of: ' .. table.concat(C.VALID_LUA_TARGETS, ', '),
      }, '\n'))
    end
  elseif cliInput == '-o' or cliInput == '--outDir' then
    outDir = cliOption(cliInput)
  elseif cliInput == '-b' or cliInput == '--bitLib' then
    C.BITLIB = cliOption(cliInput)
  elseif cliInput:sub(1, 1) == '-' then
    terminate('Unrecognized option: ' .. cliInput)
  else
    table.insert(args, cliInput)
  end

  cliInputsIndex = cliInputsIndex + 1
end

-- -----------------------------------------------------------------------------
-- Main
-- -----------------------------------------------------------------------------

C.IS_CLI_RUNTIME = true

if subCommand == 'compile' then
  if #args == 0 then
    terminate('Missing arg')
  elseif watch then
    -- Use pcall to catch SIGINT
    pcall(function() watchFiles(args) end)
  else
    traverseFiles(args, '%.erde$', function(filePath)
      if not compileFile(filePath) then
        os.exit(1)
      end
    end)
  end
elseif subCommand == 'clean' then
  if #args == 0 then
    terminate('Missing arg')
  end
  traverseFiles(args, '%.lua$', function(filePath)
    if isCompiledFile(filePath) then
      os.remove(filePath)
      print(filePath .. ' => DELETED')
    end
  end)
elseif #args == 0 then
  repl()
elseif not utils.fileExists(args[1]) then
  terminate('File does not exist: ' .. args[1])
else
  lib.load()
  runFile(args[1])
end
