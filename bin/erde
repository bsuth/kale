#!/usr/bin/env lua

local argparse = require('argparse')
local lfs = require('lfs')
local C = require('erde.constants')
local compile = require('erde.compile')
local luaTarget = require('erde.luaTarget')
local lib = require('erde.lib')
local utils = require('erde.utils')

local load = loadstring or load

local CWD = lfs.currentdir()
C.IS_CLI_RUNTIME = true

-- -----------------------------------------------------------------------------
-- Helpers
-- -----------------------------------------------------------------------------

-- Check whether a file has been generated from `erde` by checking if the file
-- ends with `C.COMPILED_FOOTER_COMMENT`.
local function isCompiledFile(filePath)
  local file = io.open(filePath, 'r')

  if file == nil then
    return false
  end

  file:seek('end', -#C.COMPILED_FOOTER_COMMENT_LEN)
  local footer = file:read(#C.COMPILED_FOOTER_COMMENT_LEN)
  file:close()

  return footer == C.COMPILED_FOOTER_COMMENT
end

local function traversePaths(paths, callback)
  for i, path in ipairs(paths) do
    local attributes = lfs.attributes(path)

    if attributes ~= nil then
      if attributes.mode == 'file' then
        callback(path)
      elseif attributes.mode == 'directory' then
        local subPaths = {}

        for fileName in lfs.dir(path) do
          if fileName ~= '.' and fileName ~= '..' then
            subPaths[#subPaths + 1] = utils.joinPaths(path, fileName)
          end
        end

        traversePaths(subPaths, callback)
      end
    end
  end
end

local function traverseErdeFiles(paths, callback)
  traversePaths(paths, function(filePath)
    if filePath:match('%.erde$') then
      callback(filePath)
    end
  end)
end

local function traverseLuaFiles(paths, callback)
  traversePaths(paths, function(filePath)
    if filePath:match('%.lua$') then
      callback(filePath)
    end
  end)
end

-- -----------------------------------------------------------------------------
-- CLI
-- -----------------------------------------------------------------------------

local cli = argparse('erde')

local function option(shortFlag, longFlag, description)
  local longName = longFlag:sub(3)

  local option = cli:option({
    argname = '<'..longName..'>',
    target = longName,
    description = description,
  })

  -- Hack to customize help output. We use this to force the flags to remain
  -- on one line and deduplicate the argname.
  option._public_aliases = { shortFlag .. ', ' .. longFlag }
  option._aliases = { shortFlag, longFlag }

  return option
end

cli._usage = 'Usage: erde [-C|-X] [PATH...]'

cli:description(
  table.concat({
    'erde is the CLI for running and compiling `*.erde` files.',
    'It expects either zero or one "main" flags to determine what to do (similar to pacman operations).',
    'No main flag is used for both the REPL and running *.erde files directly,',
    'while the -C and -X flags are used for compiling and cleaning.',
  }, ' ')
)

cli:epilog(
  table.concat({
    'Examples:',
    '   erde',
    '      Launch the REPL',
    '',
    '   erde my_script.erde my_other_script.erde',
    '      Run my_script.erde first, then my_other_script.erde. Compilation is done in memory.',
    '',
    '   erde -C',
    '      Compile all *.erde files under the current directory.',
    '',
    '   erde -C my_script.erde',
    '      Compile my_script.erde (into my_script.lua).',
    '',
    '   erde -C src',
    '      Compile all *.erde files in src.',
    '',
    '   erde -C -o dest src',
    '      Compile all *.erde files in src and place the *.lua files under dest.',
    '',
    '   erde -X',
    '      Remove all generated *.lua files under the current directory.',
    '',
    '   erde -X src',
    '      Remove all generated *.lua files in src.',
    '',
    '   erde -X my_script.lua',
    '      Remove my_script.lua if and only if it has been generated by this script.',
  }, '\n')
)

cli:flag('-v --version', 'Show version and exit.')
cli:argument('paths'):args('*'):hidden(true)

cli:flag('-X --clean'):hidden(true)
cli:flag('-C --compile'):hidden(true)

cli:group('-C, --compile',
  option('-t', '--target', 'Lua target. Must be one of:\n  ' .. table.concat(C.VALID_LUA_TARGETS, ', ')),
  option('-o', '--outDir', 'Output directory for compiled files.')
)

local args = cli:parse()

-- -----------------------------------------------------------------------------
-- Actions
-- -----------------------------------------------------------------------------

local function cleanFile(filePath)
  if isCompiledFile(filePath) then
    os.remove(filePath)
    print('Removed ' .. filePath)
  end
end

local function compileFile(filePath)
  local destFilePath = filePath:gsub('%.erde$', '.lua')

  if args.outDir then
    destFilePath = destFilePath:gsub(CWD, args.outDir)
  end

  if utils.fileExists(destFilePath) and not isCompiledFile(destFilePath) then
    error('Cannot write to ' .. destFilePath .. ': File already exists')
  end

  local srcFile = io.open(filePath, 'r')
  local compiled = compile(srcFile:read('*a'))
  srcFile:close()

  local destFile = io.open(destFilePath, 'w')
  destFile:write(compiled)

  print(
    filePath:gsub(CWD .. C.PATH_SEPARATOR, '')
    .. ' -> '
    .. destFilePath:gsub(CWD .. C.PATH_SEPARATOR, '')
  )
end

-- IMPORTANT: THIS IS AN ERDE CODE LOADER AND MUST ADHERE TO THE USAGE SPEC OF
-- `__erde_internal_load_source__`!
local function runFile(filePath)
  local ok, result = xpcall(
    function()
      local sourceCode = utils.readFile(filePath)
      local result = lib.__erde_internal_load_source__(sourceCode, filePath)
      return result
    end,
    function(err)
      if type(err) == 'table' and err.__is_erde_internal_load_error__ then
        return err.stacktrace
      elseif not utils.fileExists(filePath) then
        return 'file does not exist: ' .. filePath
      else
        -- This should never happen?
        return 'internal error, please report this at: '
      end
    end
  )

  if not ok then
    -- Do not use `error` here! Need to preserve stack trace in `result`.
    print('erde: ' .. result)
    os.exit(1)
  end

  return result
end

-- -----------------------------------------------------------------------------
-- Main
-- -----------------------------------------------------------------------------

if args.target then
  luaTarget.current = args.target
end

if args.version then
  print('0.2-1')
elseif args.compile then
  traverseErdeFiles(#args.paths > 0 and args.paths or { '.' }, compileFile)
elseif args.clean then
  traverseLuaFiles(#args.paths > 0 and args.paths or { '.' }, cleanFile)
elseif #args.paths == 0 then
  print('REPL not yet supported.')
else
  lib.load()
  for i, path in ipairs(args.paths) do
    runFile(path)
  end
end
