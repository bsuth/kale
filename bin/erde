#!/usr/bin/env lua

local argparse = require('argparse')
local lfs = require('lfs')
local C = require('erde.constants')
local compile = require('erde.compile')
local lib = require('erde.lib')
local utils = require('erde.utils')

local load = loadstring or load

local CWD = lfs.currentdir()
C.IS_CLI_RUNTIME = true

-- -----------------------------------------------------------------------------
-- Helpers
-- -----------------------------------------------------------------------------

-- Check whether a file has been generated from `erde` by checking if the file
-- ends with `C.COMPILED_FOOTER_COMMENT`.
local function isCompiledFile(filePath)
  local file = io.open(filePath, 'r')

  if file == nil then
    return false
  end

  file:seek('end', -C.COMPILED_FOOTER_COMMENT_LEN)
  local footer = file:read(C.COMPILED_FOOTER_COMMENT_LEN)
  file:close()

  return footer == C.COMPILED_FOOTER_COMMENT
end

local function traversePaths(paths, callback)
  for i, path in ipairs(paths) do
    local attributes = lfs.attributes(path)

    if attributes ~= nil then
      if attributes.mode == 'file' then
        callback(path)
      elseif attributes.mode == 'directory' then
        local subPaths = {}

        for fileName in lfs.dir(path) do
          if fileName ~= '.' and fileName ~= '..' then
            subPaths[#subPaths + 1] = utils.joinPaths(path, fileName)
          end
        end

        traversePaths(subPaths, callback)
      end
    end
  end
end

local function traverseErdeFiles(paths, callback)
  traversePaths(paths, function(filePath)
    if filePath:match('%.erde$') then
      callback(filePath)
    end
  end)
end

local function traverseLuaFiles(paths, callback)
  traversePaths(paths, function(filePath)
    if filePath:match('%.lua$') then
      callback(filePath)
    end
  end)
end

local function addOption(parser, shortFlag, longFlag, description)
  local longName = longFlag:sub(3)

  local option = parser:option({
    argname = '<'..longName..'>',
    target = longName,
    description = description,
  })

  -- Hack to customize help output. We use this to force the flags to remain
  -- on one line and deduplicate the argname.
  option._public_aliases = { shortFlag .. ', ' .. longFlag }
  option._aliases = { shortFlag, longFlag }

  return option
end

-- -----------------------------------------------------------------------------
-- CLI
-- -----------------------------------------------------------------------------

local cli = argparse('erde')
cli._usage = 'Usage: erde [command] [args]'

cli:add_complete()
cli:require_command(false)
cli:flag('-v --version', 'Show version and exit.')

cli:epilog(
  table.concat({
    'Examples:',
    '   erde repl',
    '      Launch the REPL',
    '',
    '   erde run my_script.erde',
    '      Run my_script.erde.',
    '',
    '   erde compile',
    '      Compile all *.erde files under the current directory.',
    '',
    '   erde compile my_script.erde',
    '      Compile my_script.erde (into my_script.lua).',
    '',
    '   erde compile src',
    '      Compile all *.erde files in src.',
    '',
    '   erde compile -o dest src',
    '      Compile all *.erde files in src and place the *.lua files under dest.',
    '',
    '   erde clean',
    '      Remove all generated *.lua files under the current directory.',
    '',
    '   erde clean src',
    '      Remove all generated *.lua files in src.',
    '',
    '   erde clean my_script.lua',
    '      Remove my_script.lua if and only if it has been generated by this script.',
  }, '\n')
)

local cliRepl = cli:command('repl', 'Launch the Erde REPL.')
cliRepl._usage = 'Usage: erde repl'

local cliRun = cli:command('run', 'Run an Erde file from the command line.')
cliRun._usage = 'Usage: erde run [options] [script]'
cliRun:flag('-d --debug', 'Expose internal stack calls in tracebacks.')
addOption(cliRun, '-t', '--target', 'Lua target. Must be one of:\n' .. table.concat(C.VALID_LUA_TARGETS, ', '))
cliRun:argument('script'):args(1):hidden(true)

local cliCompile = cli:command('compile', 'Compile Erde files into Lua.')
cliCompile._usage = 'Usage: erde compile [options] [paths]'
addOption(cliCompile, '-t', '--target', 'Lua target. Must be one of:\n' .. table.concat(C.VALID_LUA_TARGETS, ', '))
addOption(cliCompile, '-o', '--outDir', 'Output directory for compiled files.')
addOption(cliCompile, '-b', '--bitLib', 'Library for bit operations.')
cliCompile:argument('paths'):args('*'):hidden(true)

local cliClean = cli:command('clean',  'Remove generated Lua files.')
cliClean._usage = 'Usage: erde clean [paths]'
cliClean:argument('paths'):args('*'):hidden(true)

local args = cli:parse()

-- -----------------------------------------------------------------------------
-- Actions
-- -----------------------------------------------------------------------------

local function cleanFile(filePath)
  if isCompiledFile(filePath) then
    os.remove(filePath)
    print('Removed ' .. filePath)
  end
end

local function compileFile(filePath)
  local destFilePath = filePath:gsub('%.erde$', '.lua')

  if args.outDir then
    destFilePath = destFilePath:gsub(CWD, args.outDir)
  end

  if utils.fileExists(destFilePath) and not isCompiledFile(destFilePath) then
    error('Cannot write to ' .. destFilePath .. ': File already exists')
  end

  local srcFile = io.open(filePath, 'r')
  local compiled = compile(srcFile:read('*a'))
  srcFile:close()

  local destFile = io.open(destFilePath, 'w')
  destFile:write(compiled)

  print(
    filePath:gsub(CWD .. C.PATH_SEPARATOR, '')
    .. ' -> '
    .. destFilePath:gsub(CWD .. C.PATH_SEPARATOR, '')
  )
end

-- IMPORTANT: THIS IS AN ERDE SOURCE LOADER AND MUST ADHERE TO THE USAGE SPEC OF
-- `__erde_internal_load_source__`!
local function runFile(filePath)
  local ok, result = xpcall(
    function()
      local sourceCode = utils.readFile(filePath)
      local result = lib.__erde_internal_load_source__(sourceCode, filePath)
      return result
    end,
    function(err)
      if type(err) == 'table' and err.__is_erde_error__ then
        return err.stacktrace
      elseif not utils.fileExists(filePath) then
        return 'file does not exist: ' .. filePath
      else
        return table.concat({
          'internal error: ' .. tostring(err),
          'please report this at: https://github.com/erde-lang/erde/issues',
        }, '\n')
      end
    end
  )

  if not ok then
    -- Do not use `error` here! Need to preserve stack trace in `result`.
    print('erde: ' .. result)
    os.exit(1)
  end

  return result
end

-- -----------------------------------------------------------------------------
-- Main
-- -----------------------------------------------------------------------------

if args.target and C.VALID_LUA_TARGETS[args.target] then
  C.LUA_TARGET = args.target
end

if args.bitLib then
  C.BITLIB = args.bitLib
end

if args.debug then
  C.DEBUG = true
end

if args.version then
  print('0.3-1')
elseif args.run then
  lib.load()
  runFile(args.script)
elseif args.compile then
  traverseErdeFiles(#args.paths > 0 and args.paths or { '.' }, compileFile)
elseif args.clean then
  traverseLuaFiles(#args.paths > 0 and args.paths or { '.' }, cleanFile)
else
  print('repl not support yet')
end
