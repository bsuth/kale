#!/usr/bin/env luajit

local argparse = require('argparse')
local lfs = require('lfs')
local erde = require('erde')
require('erde.loader')

local COMPILE_FOOTER_TAG = 'ERDE_META'

-- -----------------------------------------------------------------------------
-- Path Helpers
-- -----------------------------------------------------------------------------

local path = { sep = _G.package.config:sub(1, 1) }

function path.join(...)
  return table.concat({ ... }, path.sep):gsub(path.sep .. '+', path.sep)
end

local fs = {}

function fs.exists(filePath)
  local file = io.open(filePath, 'r')

  if file ~= nil then
    file:close()
    return true
  end

  return false
end

-- -----------------------------------------------------------------------------
-- Helpers
-- -----------------------------------------------------------------------------

local function contains(t, element)
  for i, value in ipairs(t) do
    if value == element then
      return true
    end
  end

  return false
end

-- TODO: make this cross platform + error handling?
-- 1) Stopping point (dont use $HOME?)
local function getManifest()
  local home = os.getenv('HOME')
  local restoreDir = lfs.currentdir()

  local manifestRoot = restoreDir
  local manifestFile = io.open(path.join(manifestRoot, 'manifest.erde'), 'r')
  while manifestFile == nil and manifestRoot:find(home) do
    lfs.chdir('..')
    manifestRoot = lfs.currentdir()
    manifestFile = io.open(path.join(manifestRoot, 'manifest.erde'), 'r')
  end

  lfs.chdir(restoreDir)

  if manifestFile == nil then
    return {}, nil
  end

  local manifestContents = manifestFile:read('*a')
  manifestFile:close()
  local parsedManifest = erde.parse(manifestContents)
  local compiledManifest = erde.compile(parsedManifest)

  local loadedManifest = (loadstring or load)(compiledManifest)
  if not loadedManifest then
    return {}, nil
  end

  return loadedManifest(), manifestRoot
end

local function traverseDir(root, excludeDirs, callback)
  for fileName in lfs.dir(root) do
    if fileName ~= '.' and fileName ~= '..' and fileName ~= 'manifest.erde' then
      local filePath = path.join(root, fileName)
      local attributes = lfs.attributes(filePath)

      if attributes ~= nil then
        if attributes.mode == 'directory' then
          if not contains(excludeDirs, filePath) then
            traverseDir(filePath, excludeDirs, callback)
          end
        elseif attributes.mode == 'file' then
          callback(filePath)
        end
      end
    end
  end
end

local function traverseErdeFiles(root, excludeDirs, callback)
  traverseDir(root, excludeDirs, function(filePath)
    if filePath:match('%.erde$') then
      callback(filePath)
    end
  end)
end

local function traverseLuaFiles(root, excludeDirs, callback)
  traverseDir(root, excludeDirs, function(filePath)
    if filePath:match('%.lua$') then
      callback(filePath)
    end
  end)
end

-- -----------------------------------------------------------------------------
-- CLI
-- -----------------------------------------------------------------------------

local cli = argparse('erde')
cli:require_command(false)
cli:add_complete()

-- The current Erde version.
cli:flag('-v --version', 'Print version and exit.')

-- The Lua version to use.
cli:option('-l --luaVersion')

-- The root directory. All paths (such as those given in --include / --exclude)
-- are assumed to be relative to the root.
cli:option('--root')

-- Directories to traverse when searching for .erde files.
cli:option('--include')

-- Directories to exclude when searching for .erde files.
cli:option('--exclude')

local format = cli:command('format')

-- -----------------------------------------------------------------------------
-- Run
-- -----------------------------------------------------------------------------

local runCmd = cli:command('run')
runCmd:argument('main', 'Main file to run.'):args('*')

local function processRunCmd()
  local mainModuleNames = #args.main > 0
    and args.main
    or type(manifest.main) == 'table'
    and manifest.main
    or type(manifest.main) == 'string'
    and { manifest.main }

  if not mainModuleNames then
    error('Need to specify modules either on command line or in manifest.erde')
  end

  for i, mainModuleName in pairs(mainModuleNames) do
    require(mainModuleName:gsub('%.erde$', ''))
  end
end

-- -----------------------------------------------------------------------------
-- Compile
-- -----------------------------------------------------------------------------

local compileCmd = cli:command('compile')

-- Allow specifying files on command line. If this is present, includeDirs will
-- NOT default to root.
compileCmd:argument('files', 'Files to compile.'):args('*')

-- The directory to write compiled files to.
compileCmd:option('--outDir')

local function compileFile(srcFilePath)
  local srcFile = io.open(srcFilePath, 'r')
  local moduleContents = srcFile:read('*a')
  srcFile:close()

  local compiledModule = erde.compile(moduleContents)

  local destFilePath = srcFilePath:gsub('.erde$', '.lua')
  if outDir ~= nil then
    -- Collapse file structure if there is only 1 include dir
    if #includeDirs == 1 then
      destFilePath = destFilePath:gsub(
        includeDirs[1],
        outDir
      )
    else
      destFilePath = destFilePath:gsub(root, outDir)
    end
  end

  local destFile = io.open(destFilePath, 'w')
  destFile:write(compiledModule)

  print(
    srcFilePath:gsub(root .. path.sep, '')
    .. ' -> '
    .. destFilePath:gsub(root .. path.sep, '')
  )
end

local function processCompileCmd()
  for i, fileName in ipairs(args.files) do
    if fileName:match('%.erde$') then
      compileFile(path.join(root, fileName))
    end
  end

  for i, includeDir in ipairs(includeDirs) do
    traverseErdeFiles(includeDir, excludeDirs, compileFile)
  end
end

-- -----------------------------------------------------------------------------
-- Clean
-- -----------------------------------------------------------------------------

local cleanCmd = cli:command('clean')

-- Allow specifying files on command line. If this is present, includeDirs will
-- NOT default to root.
cleanCmd:argument('dirs', 'Directories to clean.'):args('*')

-- Clean all Erde generated files from the root. By default only files that are
-- generated by the current configuration are cleaned.
cleanCmd:flag('--hard')

local function cleanFile(filePath)
  local file = io.open(filePath, 'r')
  local head1, head2 = file:read('*l'), file:read('*l')
  file:close()
  
  if (head1 and head1:find(COMPILE_FOOTER_TAG)) or (head2 and head2:find(COMPILE_FOOTER_TAG)) then
    os.remove(filePath)
  end
end

local function processCleanCmd()
  if args.hard then
    traverseLuaFiles(root, excludeDirs, cleanFile)
  end

  if #args.dirs > 0 then
    for i, cleanDir in ipairs(args.dirs) do
      traverseLuaFiles(cleanDir, excludeDirs, cleanFile)
    end
  elseif #includeDirs > 0 then
    for i, includeDir in ipairs(includeDirs) do
      traverseLuaFiles(includeDir, excludeDirs, cleanFile)
    end

    if outDir ~= nil and fs.exists(outDir) then
      traverseLuaFiles(outDir, {}, cleanFile)
      os.remove(outDir)
    end
  else
    traverseLuaFiles('.', excludeDirs, cleanFile)
  end
end

-- -----------------------------------------------------------------------------
-- Main
-- -----------------------------------------------------------------------------

args = cli:parse()
cwd = lfs.currentdir()
manifest, manifestRoot = getManifest()
root = args.root or manifestRoot or cwd

outDir = args.outDir or manifest.outDir
outDir = outDir and path.join(root, outDir) or nil

includeDirs = {}
excludeDirs = {}
if manifest then
  if type(manifest.include) == 'table' then
    for i, includeDir in ipairs(manifest.include) do
      includeDirs[i] = path.join(root, includeDir)
    end
  end

  if type(manifest.exclude) == 'table' then
    for i, excludeDir in ipairs(manifest.exclude) do
      excludeDirs[i] = path.join(root, excludeDir)
    end
  end
end

if args.version then
  print('v0.1.0')
elseif args.run then
  processRunCmd()
elseif args.compile then
  processCompileCmd()
elseif args.clean then
  processCleanCmd()
elseif args.format then
  print('TODO')
else
  print('REPL not yet supported.')
end
